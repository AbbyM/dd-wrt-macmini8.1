diff --git a/.github/workflows/c-cpp.yml b/.github/workflows/c-cpp.yml
new file mode 100644
index 0000000..e75d170
--- /dev/null
+++ b/.github/workflows/c-cpp.yml
@@ -0,0 +1,487 @@
+name: linux-ksmbd-oot CI
+
+on:
+  push:
+    branches: [ "master" ]
+  pull_request:
+    branches: [ "master" ]
+
+jobs:
+  build:
+
+    runs-on: ubuntu-latest
+
+    steps:
+    - uses: actions/checkout@v3
+    - name: Download the kernel
+      run: |
+        sudo apt-get update
+        sudo apt-get install libelf-dev wget tar gzip python2.7
+        wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.109.tar.gz
+        tar xf linux-5.4.109.tar.gz
+        mv linux-5.4.109 linux-stable
+    - name: Prerequisite for xfstests testing
+      run: |
+        sudo apt-get install cifs-utils
+        sudo apt-get install linux-headers-$(uname -r)
+        sudo apt-get install autoconf libtool pkg-config libnl-3-dev libnl-genl-3-dev
+        sudo apt-get install xfslibs-dev uuid-dev libtool-bin xfsprogs libgdbm-dev gawk fio attr libattr1-dev libacl1-dev libaio-dev
+        sudo apt-get install liblmdb-dev libgnutls28-dev libgpgme-dev libjansson-dev libarchive-dev libacl1-dev
+        sudo apt-get install gnutls-bin libparse-yapp-perl libjansson-dev libarchive-dev libjson-perl
+        git clone https://github.com/cifsd-team/ksmbd-tools
+        export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
+        export PATH=/usr/local/lib:$PATH
+        sudo useradd fsgqa
+        sudo useradd 123456-fsgqa
+    - name: Copy ksmbd source to kernel
+      run: |
+        mv linux-stable ../
+        mkdir ../linux-stable/fs/ksmbd
+        cp -ar * ../linux-stable/fs/ksmbd/
+    - name: Compile with 5.4 kernel
+      run: |
+        cd ../linux-stable
+        yes "" | make oldconfig > /dev/null
+        echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
+        echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
+        echo 'CONFIG_SMB_SERVER=m' >> .config
+        echo 'CONFIG_SMB_INSECURE_SERVER=y' >> .config
+        echo '# CONFIG_SMB_SERVER_SMBDIRECT is not set' >> .config
+        echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
+        echo '# CONFIG_SMB_SERVER_KERBEROS5 is not set' >> .config
+        make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
+
+        yes "" | make oldconfig > /dev/null
+        echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
+        echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
+        echo 'CONFIG_SMB_SERVER=m' >> .config
+        echo '# CONFIG_SMB_INSECURE_SERVER is not set' >> .config
+        echo '# CONFIG_SMB_SERVER_SMBDIRECT is not set' >> .config
+        echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
+        echo '# CONFIG_SMB_SERVER_KERBEROS5 is not set' >> .config
+        make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
+
+        yes "" | make oldconfig > /dev/null
+        echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
+        echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
+        echo 'CONFIG_SMB_SERVER=m' >> .config
+        echo '# CONFIG_SMB_INSECURE_SERVER is not set' >> .config
+        echo '# CONFIG_SMB_SERVER_SMBDIRECT is not set' >> .config
+        echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
+        echo 'CONFIG_SMB_SERVER_KERBEROS5=y' >> .config
+        make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
+    - name: Compile and insmod ksmbd module
+      run: |
+        cd ../ksmbd
+        make > /dev/null
+        sudo make install > /dev/null
+        sudo modprobe ksmbd
+        sudo modprobe cifs
+    - name: Compile and install ksmbd-tools
+      run: |
+        cd ksmbd-tools
+        ./autogen.sh
+        ./configure --sysconfdir=/etc --with-rundir=/run
+        make -j$((`nproc`+1))
+        sudo make install
+    - name: Run xfstests testsuite
+      run: |
+        cd ..
+        sudo mkdir -p /etc/ksmbd/
+        sudo mkdir -p /mnt/1
+        sudo mkdir -p /mnt/2
+        sudo mkdir -m 777 -p /mnt/test1
+        sudo mkdir -m 777 -p /mnt/test2
+        sudo mkdir -m 777 -p /mnt/test3
+        ksmbd.adduser -i ./ksmbdpwd.db -a testuser -p 1234
+        git clone https://github.com/cifsd-team/cifsd-test-result
+        cp cifsd-test-result/testsuites/smb.conf .
+        sudo ksmbd.mountd -n --c=./smb.conf --u=./ksmbdpwd.db&
+        sleep 1
+        ps -ax | grep smbd
+        cd cifsd-test-result/testsuites
+        tar xzvf xfstests-cifsd.tgz > /dev/null
+        cd xfstests-cifsd
+        make -j$((`nproc`+1)) > /dev/null
+        sudo ./check cifs/001
+        sudo ./check generic/001
+        sudo ./check generic/002
+        sudo ./check generic/005
+        sudo ./check generic/006
+        sudo ./check generic/007
+        sudo ./check generic/008
+        sudo ./check generic/010
+        sed -e "s/count=1000/count=100/" -e "s/-p 5/-p 3/" tests/generic/011 > tests/generic/011.new
+        sed -e "s/-p 5/-p 3/" tests/generic/011.out > tests/generic/011.out.new
+        mv tests/generic/011.new tests/generic/011
+        mv tests/generic/011.out.new tests/generic/011.out
+        sudo ./check generic/011
+        sudo ./check generic/013
+        sudo ./check generic/014
+        sudo ./check generic/023
+        sudo ./check generic/024
+        sudo ./check generic/028
+        sudo ./check generic/029
+        sudo ./check generic/030
+        sudo ./check generic/032
+        sudo ./check generic/033
+        sudo ./check generic/036
+        sudo ./check generic/037
+        sudo ./check generic/043
+        sudo ./check generic/044
+        sudo ./check generic/045
+        sudo ./check generic/046
+        sudo ./check generic/051
+        sudo ./check generic/069
+        sudo ./check generic/070
+        sudo ./check generic/071
+        sudo ./check generic/072
+        sudo ./check generic/074
+        sudo ./check generic/080
+        sudo ./check generic/084
+        sudo ./check generic/086
+        sudo ./check generic/091
+        sudo ./check generic/095
+        sudo ./check generic/098
+        sudo ./check generic/100
+        sudo ./check generic/103
+        sudo ./check generic/109
+        sudo ./check generic/113
+        sudo ./check generic/117
+        sudo ./check generic/124
+        sudo ./check generic/125
+        sudo ./check generic/129
+        sudo ./check generic/130
+        sudo ./check generic/132
+        sudo ./check generic/133
+        sudo ./check generic/135
+        sudo ./check generic/141
+        sudo ./check generic/169
+        sudo ./check generic/198
+        sudo ./check generic/207
+        sudo ./check generic/208
+        sudo ./check generic/210
+        sudo ./check generic/211
+        sudo ./check generic/212
+        sudo ./check generic/214
+        sudo ./check generic/215
+        sudo ./check generic/221
+        sudo ./check generic/225
+        sudo ./check generic/228
+        sudo ./check generic/236
+        sudo ./check generic/239
+        sudo ./check generic/241
+        sudo ./check generic/245
+        sudo ./check generic/246
+        sudo ./check generic/247
+        sudo ./check generic/248
+        sudo ./check generic/249
+        sudo ./check generic/257
+        sudo ./check generic/258
+        sudo ./check generic/263
+        sudo ./check generic/308
+        sudo ./check generic/309
+        sudo ./check generic/310
+        sudo ./check generic/313
+        sudo ./check generic/315
+        sudo ./check generic/316
+        sudo ./check generic/323
+        sudo ./check generic/337
+        sudo ./check generic/339
+        sudo ./check generic/340
+        sudo ./check generic/344
+        sudo ./check generic/345
+        sudo ./check generic/346
+        sudo ./check generic/349
+        sudo ./check generic/350
+        sudo ./check generic/354
+        sudo ./check generic/360
+        sudo ./check generic/377
+        sudo ./check generic/391
+        sudo ./check generic/393
+        sudo ./check generic/394
+        sudo ./check generic/406
+        sudo ./check generic/412
+        sudo ./check generic/420
+        sudo ./check generic/428
+        sudo ./check generic/430
+        sudo ./check generic/431
+        sudo ./check generic/432
+        sudo ./check generic/433
+        sudo ./check generic/436
+        sudo ./check generic/437
+        sudo ./check generic/438
+        sudo ./check generic/439
+        sudo ./check generic/443
+        sudo ./check generic/445
+        sudo ./check generic/446
+        sudo ./check generic/448
+        sudo ./check generic/451
+        sudo ./check generic/452
+        sudo ./check generic/454
+        sudo ./check generic/460
+        sudo ./check generic/461
+        sudo ./check generic/464
+        sudo ./check generic/465
+        sudo ./check generic/469
+        sudo ./check generic/504
+        sudo ./check generic/523
+        sudo ./check generic/524
+        sudo ./check generic/528
+        sudo ./check generic/532
+        sudo ./check generic/533
+        sudo ./check generic/539
+        sudo ./check generic/565
+        sudo ./check generic/567
+        sudo ./check generic/568
+        sudo ./check generic/599
+
+        cd ..
+        tar xzvf samba-cifsd.tgz > /dev/null
+        cd samba-cifsd/
+        ./configure --disable-cups --disable-iprint --without-ad-dc --without-ads --without-ldap --without-pam --with-shared-modules='!vfs_snapper'
+        make -j$((`nproc`+1)) bin/smbtorture > /dev/null
+
+        # smb2 connect test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.connect
+        sudo rm -rf /mnt/test3/*
+        # smb2 read test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.read.eof
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.read.position
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.read.dir
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.read.access
+        sudo rm -rf /mnt/test3/*
+        # smb2 scan test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.scan.scan
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.scan.getinfo
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.scan.setinfo
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.scan.find
+        sudo rm -rf /mnt/test3/*
+        # smb2 dir test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.find
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.fixed
+        sudo rm -rf /mnt/test3/*
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.one
+        ##sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.many
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.modify
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.sorted
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.file-index
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.large-files
+        sudo rm -rf /mnt/test3/*
+        # smb2 rename test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.simple
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.simple_nodelete
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.no_sharing
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.share_delete_and_delete_access
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.no_share_delete_but_delete_access
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.share_delete_no_delete_access
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.msword
+        sudo rm -rf /mnt/test3/*
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.rename_dir_openfile
+        # - sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.rename_dir_bench
+        sudo rm -rf /mnt/test3/*
+        # smb2 maxfid test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.maxfid
+        sudo rm -rf /mnt/test3/*
+        # smb2 sharemode test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.sharemode.sharemode-access
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.sharemode.access-sharemode
+        sudo rm -rf /mnt/test3/*
+        # smb2 compound test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.related1
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.related2
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.related3
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.unrelated1
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.invalid1
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.invalid2
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.invalid3
+        sudo rm -rf /mnt/test3/*
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.interim1 #fail
+        # - sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.interim2
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.compound-break
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.compound-padding
+        sudo rm -rf /mnt/test3/*
+        # smb2 streams test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.dir
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.io
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.sharemodes
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.names
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.names2
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.names3
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.rename
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.rename2
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.create-disposition
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.attributes
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.delete
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.zero-byte
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.basefile-rename-with-open-stream
+        sudo rm -rf /mnt/test3/*
+        # smb2 create test
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.gentest
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.blob
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.open
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.brlocked
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.multi
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.delete
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.leading-slash
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.impersonation
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.dir-alloc-size
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.aclfile
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.acldir
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.nulldacl
+        sudo rm -rf /mnt/test3/*
+        # smb2 delete-on-close test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.delete-on-close-perms.OVERWRITE_IF
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 "smb2.delete-on-close-perms.OVERWRITE_IF Existing"
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.delete-on-close-perms.CREATE
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 "smb2.delete-on-close-perms.CREATE Existing"
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.delete-on-close-perms.CREATE_IF
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 "smb2.delete-on-close-perms.CREATE_IF Existing"
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.delete-on-close-perms.FIND_and_set_DOC
+        sudo rm -rf /mnt/test3/*
+        # smb2 oplock test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive1
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive2
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive3
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive4
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive5
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive6
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive9
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch1
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch2
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch3
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch4
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch5
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch6
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch7
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch8
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch9
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch9a
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch10
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch11
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch12
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch13
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch14
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch15
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch16
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch19
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch20
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch21
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch22
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch23
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch24
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch25
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch26 #fail
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.stream1 #fail
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.doc
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.brl1
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.brl2
+        sudo rm -rf /mnt/test3/*
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.brl3
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.levelii500
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.levelii501
+        sudo rm -rf /mnt/test3/*
+        #./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.levelii502
+        #sudo rm -rf /mnt/test3/*
+        # smb2 session test
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reconnect1
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reconnect2
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reauth1
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reauth2
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reauth3
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reauth4
+        # smb2 lock test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.valid-request
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.rw-shared
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.rw-exclusive
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.auto-unlock
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.async
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.cancel
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.cancel-tdis
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.cancel-logoff
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.zerobytelength
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.zerobyteread
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.unlock
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.multiple-unlock
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.stacking
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.contend
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.context
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.truncate
+        # smb2 leases test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.request
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.nobreakself
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.statopen
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.statopen2
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.statopen3
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.upgrade
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.upgrade2
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.upgrade3
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.break
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.oplock
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.multibreak
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking1
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking2
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking3
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking4
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking5
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking6
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.lock1
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.complex1
+        ##./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.timeout
+        # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.unlink
+        # smb2 acls test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.CREATOR
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.GENERIC
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.OWNER
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.INHERITANCE
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.INHERITFLAGS
+        sudo rm -rf /mnt/test3/*
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.DYNAMIC
+        # smb2 credits test
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.credits.session_setup_credits_granted
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.credits.single_req_credits_granted
+        ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.credits.skipped_mid
diff --git a/.travis.yml b/.travis.yml
deleted file mode 100644
index fc6c463..0000000
--- a/.travis.yml
+++ /dev/null
@@ -1,531 +0,0 @@
-dist: bionic
-
-language: c
-
-notifications:
- - email: true
-
-before_script:
- # Download the kernel
- - sudo apt-get install libelf-dev wget tar gzip python
- - wget --no-check-certificate https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.109.tar.gz
- - tar xf linux-5.4.109.tar.gz
- - mv linux-5.4.109 linux-stable
-   # - ./.travis_get_mainline_kernel
- - cp ./.travis_cmd_wrapper.pl ~/travis_cmd_wrapper.pl
- # Prerequisite for xfstests testing
- - sudo apt-get install cifs-utils
- - sudo apt-get install linux-headers-$(uname -r)
- - sudo apt-get install autoconf libtool pkg-config libnl-3-dev libnl-genl-3-dev
- - sudo apt-get install xfslibs-dev uuid-dev libtool-bin xfsprogs libgdbm-dev gawk fio attr libattr1-dev libacl1-dev libaio-dev
- - git clone https://github.com/cifsd-team/ksmbd-tools
- - git clone https://github.com/cifsd-team/cifsd-test-result
- - export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
- - export PATH=/usr/local/lib:$PATH
- - sudo useradd fsgqa
- - sudo useradd 123456-fsgqa
- # Prerequisite for smbtorture testing
- - sudo apt-get install liblmdb-dev libgnutls28-dev libgpgme-dev libjansson-dev libarchive-dev libacl1-dev
-
-script:
- # Copy ksmbd source to kernel
- - mv linux-stable ../
- #- mv linux ../
- - mkdir ../linux-stable/fs/ksmbd
- - cp -ar * ../linux-stable/fs/ksmbd/
-# - mkdir ../linux/fs/ksmbd
-#- cp -ar * ../linux/fs/ksmbd/
-
- # Compile with 5.4 kernel
- - cd ../linux-stable
- - yes "" | make oldconfig > /dev/null
- - echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
- - echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
- - echo 'CONFIG_SMB_SERVER=m' >> .config
- - echo 'CONFIG_SMB_INSECURE_SERVER=y' >> .config
- - echo '# CONFIG_SMB_SERVER_SMBDIRECT is not set' >> .config
- - echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
- - echo '# CONFIG_SMB_SERVER_KERBEROS5 is not set' >> .config
- - make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
-
- # Compile with latest Torvalds' kernel
- # - cd ../linux
- # - yes "" | make oldconfig > /dev/null
- # - echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
- # - echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
- # - echo 'CONFIG_SMB_SERVER=m' >> .config
- # - echo 'CONFIG_SMB_INSECURE_SERVER=y' >> .config
- # - echo 'CONFIG_SMB_SERVER_SMBDIRECT=y' >> .config
- # - echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
- # - echo '# CONFIG_SMB_SERVER_KERBEROS5 is not set' >> .config
-# - make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
-
- # Compile secure server build (no smb1.0 & smb2.0) with 5.4 kernel
- - cd ../linux-stable
- - yes "" | make oldconfig > /dev/null
- - echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
- - echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
- - echo 'CONFIG_SMB_SERVER=m' >> .config
- - echo '# CONFIG_SMB_INSECURE_SERVER is not set' >> .config
- - echo '# CONFIG_SMB_SERVER_SMBDIRECT is not set' >> .config
- - echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
- - echo '# CONFIG_SMB_SERVER_KERBEROS5 is not set' >> .config
- - make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
-
- # Compile secure server build (no smb1/smb2) with latest Torvalds' kernel
- # - cd ../linux
- # - yes "" | make oldconfig > /dev/null
- # - echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
- # - echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
- # - echo 'CONFIG_SMB_SERVER=m' >> .config
- # - echo '# CONFIG_SMB_INSECURE_SERVER is not set' >> .config
- # - echo '# CONFIG_SMB_SERVER_SMBDIRECT is not set' >> .config
- # - echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
- # - echo '# CONFIG_SMB_SERVER_KERBEROS5 is not set' >> .config
-# - make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
-
- # Compile secure server build + SMBD with latest Torvalds' kernel
- # - cd ../linux
- # - yes "" | make oldconfig > /dev/null
- # - echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
- # - echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
- # - echo 'CONFIG_SMB_SERVER=m' >> .config
- # - echo '# CONFIG_SMB_INSECURE_SERVER is not set' >> .config
- # - echo 'CONFIG_SMB_SERVER_SMBDIRECT=y' >> .config
- # - echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
- # - echo '# CONFIG_SMB_SERVER_KERBEROS5 is not set' >> .config
-# - make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
-
- # Compile secure server build + Kerberos  with 5.4 kernel
- - cd ../linux-stable
- - yes "" | make oldconfig > /dev/null
- - echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
- - echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
- - echo 'CONFIG_SMB_SERVER=m' >> .config
- - echo '# CONFIG_SMB_INSECURE_SERVER is not set' >> .config
- - echo '# CONFIG_SMB_SERVER_SMBDIRECT is not set' >> .config
- - echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
- - echo 'CONFIG_SMB_SERVER_KERBEROS5=y' >> .config
- - make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
-
- # Compile secure server build + SMBD + Kerberos with latest Torvalds' kernel
- # - cd ../linux
- # - yes "" | make oldconfig > /dev/null
- # - echo 'obj-$(CONFIG_SMB_SERVER) += ksmbd/' >> fs/Makefile
- # - echo 'source "fs/ksmbd/Kconfig"' >> fs/Kconfig
- # - echo 'CONFIG_SMB_SERVER=m' >> .config
- # - echo '# CONFIG_SMB_INSECURE_SERVER is not set' >> .config
- # - echo 'CONFIG_SMB_SERVER_SMBDIRECT=y' >> .config
- # - echo '# CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN is not set' >> .config
- # - echo 'CONFIG_SMB_SERVER_KERBEROS5=y' >> .config
-# - make -j$((`nproc`+1)) fs/ksmbd/ksmbd.ko
-
- # Run xfstests testsuite
- - cd ../ksmbd
- - make > /dev/null
- - sudo make install > /dev/null
- - sudo modprobe ksmbd
- - sudo modprobe cifs
- - cd ksmbd-tools
- - ./autogen.sh > /dev/null
- - ./configure --sysconfdir=/etc --with-rundir=./ > /dev/null
- - make -j$((`nproc`+1)) > /dev/null
- - sudo make install > /dev/null
- - cd ..
- - sudo mkdir -p /etc/ksmbd/
- - sudo mkdir -p /mnt/1
- - sudo mkdir -p /mnt/2
- - sudo mkdir -m 777 -p /mnt/test1
- - sudo mkdir -m 777 -p /mnt/test2
- - sudo mkdir -m 777 -p /mnt/test3
- - ksmbd.adduser -i ./ksmbdpwd.db -a testuser -p 1234
- - cp cifsd-test-result/testsuites/smb.conf .
- - ksmbd.mountd -n --c=./smb.conf --u=./ksmbdpwd.db&
- - ps -ax | grep smbd
- - cd cifsd-test-result/testsuites/
- - tar xzvf xfstests-cifsd.tgz > /dev/null
- - cd xfstests-cifsd
- - ./configure > /dev/null
- - make -j$((`nproc`+1)) > /dev/null
- - sudo ./check cifs/001
- - sudo ./check generic/001
- - sudo ./check generic/002
- - sudo ./check generic/005
- - sudo ./check generic/006
- - sudo ./check generic/007
- - sed -e "s/count=1000/count=100/" -e "s/-p 5/-p 3/" tests/generic/011 > tests/generic/011.new
- - sed -e "s/-p 5/-p 3/" tests/generic/011.out > tests/generic/011.out.new
- - mv tests/generic/011.new tests/generic/011
- - mv tests/generic/011.out.new tests/generic/011.out
- - sudo ./check generic/011
- - sed -e s/count=1000/count=100/ -e s/procs=20/procs=10/ tests/generic/013 > tests/generic/013.new
- - mv tests/generic/013.new tests/generic/013
- - sed -e "s/-p 20/-p 10/" tests/generic/013.out > tests/generic/013.out.new
- - mv tests/generic/013.out.new tests/generic/013.out
- - sudo ./check generic/013
- - sudo ./check generic/014
- - sudo ./check generic/023
- - sudo ./check generic/024
- - sudo ./check generic/028
- - sudo ./check generic/029
- - sudo ./check generic/030
- - sudo ./check generic/032
- - sudo ./check generic/033
- - sudo ./check generic/036
- - sudo ./check generic/037
- - sed -e s/3000000/30000/ tests/generic/069 > tests/generic/069.new
- - mv tests/generic/069.new tests/generic/069
- - sed -e s/3000000/30000/ tests/generic/069.out > tests/generic/069.out.new
- - mv tests/generic/069.out.new tests/generic/069.out
- - sudo ./check generic/069
-# - travis_wait sudo ./check generic/070 (timeover > 10m)
- - sed -e s/numloops=10/numloops=2/ -e s/numfiles=5/numfiles=2/ -e s/numchildren=3/numchildren=2/ tests/generic/074 > tests/generic/074.new
- - mv tests/generic/074.new tests/generic/074
- - sudo ./check generic/074
-# - sed -e "s/expr 10/expr 5/" -e "s/numops1=1000/numops1=100/" -e "s/numops2=10000/numops2=1000/" tests/generic/075 > tests/generic/075.new
-# - mv tests/generic/075.new tests/generic/075
-# - sudo ./check generic/075
- - sudo ./check generic/080
- - sudo ./check generic/084
- - sudo ./check generic/086
-# - sed -e "s/-N 10000/-N 900/" -e "s/-l 500000/-l 5000/" tests/generic/091 > tests/generic/091.new
-# - mv tests/generic/091.new tests/generic/091
-# - sed -e "s/-N 10000/-N 900/" -e "s/-l 500000/-l 5000/" tests/generic/091.out > tests/generic/091.out.new
-# - mv tests/generic/091.out.new tests/generic/091.out
-# - sudo ./check generic/091
- - sudo ./check generic/095
- - sudo ./check generic/098
- - sed -e s/SIZE=10/SIZE=7/ -e s/DEPTH=5/DEPTH=3/ tests/generic/100 > tests/generic/100.new
- - mv tests/generic/100.new tests/generic/100
- - sudo ./check generic/100
- - sudo ./check generic/109
-# - sed -e "s/expr 10/expr 5/" -e "s/numops1=1000/numops1=100/" -e "s/numops2=10000/numops2=1000/" tests/generic/112 > tests/generic/112.new
-# - mv tests/generic/112.new tests/generic/112
-# - sudo ./check generic/112
- - sudo ./check generic/113
-# - time_wait sudo ./check generic/117 (timeover > 10m)
- - sudo ./check generic/124
- - sudo ./check generic/125
-# - travis_wait sudo ./check generic/127 (timeover > 10m)
- - sed -e "s/-i 100000/-i 70000/" -e "s/-i 100000/-i 70000/" tests/generic/129 > tests/generic/129.new
- - mv tests/generic/129.new tests/generic/129
- - sudo ./check generic/129
- - sudo ./check generic/130
- - sudo ./check generic/132
- - sudo ./check generic/133
- - sudo ./check generic/135
- - sudo ./check generic/141
- - sudo ./check generic/169
- - sudo ./check generic/198
- - sudo ./check generic/207
- - sudo ./check generic/208
- - sudo ./check generic/210
- - sudo ./check generic/211
- - sudo ./check generic/212
- - sudo ./check generic/214
- - sudo ./check generic/215
- - sudo ./check generic/221
- - sudo ./check generic/239
- - sudo ./check generic/245
- - sudo ./check generic/246
- - sudo ./check generic/247
- - sudo ./check generic/248
- - sudo ./check generic/249
- - sudo ./check generic/257
- - sudo ./check generic/258
-# - sudo ./check generic/263 #fail, It may be ksmbd issue
-# - sudo ./check generic/285 #fail, It may be cifs client issue on 4.15 kernel
- - sed -e "s/<< 20/<< 10/g" tests/generic/286 > tests/generic/286.new
- - mv tests/generic/286.new tests/generic/286
- - sudo ./check generic/286
- - sudo ./check generic/308
- - sudo ./check generic/309
- - sudo ./check generic/310
- - sudo ./check generic/313
- - sudo ./check generic/315
-# - sudo ./check generic/323
- - sudo ./check generic/337 #check
- - sudo ./check generic/340
- - sudo ./check generic/344
- - sudo ./check generic/345
- - sudo ./check generic/346
- - sudo ./check generic/349
- - sudo ./check generic/350
- - sudo ./check generic/354
- - sudo ./check generic/360
- - sudo ./check generic/377
- - sudo ./check generic/391
- - sudo ./check generic/393
- - sudo ./check generic/394
- - sudo ./check generic/406
- - sudo ./check generic/412
- - sudo ./check generic/420
-# - sudo ./check generic/422
-# - sudo ./check generic/432 5.4 kernel cifs issue (duplicate extent to file)
-# - sudo ./check generic/433 5.4 kernel cifs issue (duplicate extent to file)
- - sudo ./check generic/436
- - sudo ./check generic/437
-# - travis_wait sudo ./check generic/438 (timeover > 10m)
- - sudo ./check generic/445
- - sudo ./check generic/448
- - sudo ./check generic/451
-# - sudo ./check generic/452 (timeover > 10m)
- - sudo ./check generic/454
- - sudo ./check generic/460
- - sed -e s/BLOCK_SZ=65536/BLOCK_SZ=8192/ -e s/PROC_CNT=16/PROC_CNT=4/ tests/generic/464 > tests/generic/464.new
- - mv tests/generic/464.new tests/generic/464
- - sudo ./check generic/464
- - sudo ./check generic/465
-# - sudo ./check generic/469
-# - time_wait sudo ./check generic/476 (timeover > 10m)
-# - sudo ./check generic/490 #fail, It may be cifs client issue on 5.0 kernel
- - sudo ./check generic/504
- - sudo ./check generic/524
- - sudo ./check generic/533
-#
-#
-#
- - cd ..
- - tar xzvf samba-cifsd.tgz > /dev/null
- - cd samba-cifsd/
- - ./configure --disable-cups --disable-iprint --without-ad-dc --without-ads --without-ldap > /dev/null
- - make -j$((`nproc`+1)) bin/smbtorture > /dev/null
- # smb2 connect test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.connect
- - sudo rm -rf /mnt/test3/*
- # smb2 read test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.read.eof
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.read.position
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.read.dir
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.read.access
- - sudo rm -rf /mnt/test3/*
- # smb2 scan test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.scan.scan
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.scan.getinfo
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.scan.setinfo
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.scan.find
- - sudo rm -rf /mnt/test3/*
- # smb2 dir test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.find
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.fixed
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.one
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.many
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.modify
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.sorted
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.file-index
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.dir.large-files
- - sudo rm -rf /mnt/test3/*
- # smb2 rename test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.simple
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.simple_nodelete
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.no_sharing
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.share_delete_and_delete_access
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.no_share_delete_but_delete_access
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.share_delete_no_delete_access
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.msword
- - sudo rm -rf /mnt/test3/*
-# - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.rename_dir_openfile
-# - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.rename.rename_dir_bench
- - sudo rm -rf /mnt/test3/*
- # smb2 maxfid test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.maxfid
- - sudo rm -rf /mnt/test3/*
- # smb2 sharemode test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.sharemode.sharemode-access
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.sharemode.access-sharemode
- - sudo rm -rf /mnt/test3/*
- # smb2 compound test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.related1
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.related2
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.related3
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.unrelated1
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.invalid1
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.invalid2
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.invalid3
- - sudo rm -rf /mnt/test3/*
-# - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.interim1 #fail
-# - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.interim2
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.compound-break
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.compound.compound-padding
- - sudo rm -rf /mnt/test3/*
- # smb2 streams test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.dir
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.io
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.sharemodes
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.names
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.names2
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.names3
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.rename
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.rename2
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.create-disposition
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.attributes
-# - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.delete
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.zero-byte
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.streams.basefile-rename-with-open-stream
- - sudo rm -rf /mnt/test3/*
- # smb2 create test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.gentest
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.blob
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.open
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.brlocked
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.multi
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.delete
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.leading-slash
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.impersonation
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.dir-alloc-size
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.aclfile
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.acldir
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.create.nulldacl
- - sudo rm -rf /mnt/test3/*
- # smb2 delete-on-close test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.delete-on-close-perms.OVERWRITE_IF
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 "smb2.delete-on-close-perms.OVERWRITE_IF Existing"
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.delete-on-close-perms.CREATE
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 "smb2.delete-on-close-perms.CREATE Existing"
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.delete-on-close-perms.CREATE_IF
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 "smb2.delete-on-close-perms.CREATE_IF Existing"
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.delete-on-close-perms.FIND_and_set_DOC
- - sudo rm -rf /mnt/test3/*
- # smb2 oplock test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive1
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive2
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive3
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive4
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive5
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive6
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.exclusive9
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch1
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch2
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch3
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch4
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch5
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch6
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch7
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch8
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch9
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch9a
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch10
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch11
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch12
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch13
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch14
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch15
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch16
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch19
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch20
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch21
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch22
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch23
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch24
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch25
-# - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.batch26 #fail
-# - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.stream1 #fail
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.doc
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.brl1
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.brl2
- - sudo rm -rf /mnt/test3/*
-# - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.brl3
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.levelii500
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.levelii501
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.oplock.levelii502
- - sudo rm -rf /mnt/test3/*
- # smb2 session test
- # - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reconnect1
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reconnect2
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reauth1
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reauth2
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reauth3
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.session.reauth4
- # smb2 lock test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.valid-request
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.rw-shared
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.rw-exclusive
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.auto-unlock
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.async
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.cancel
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.cancel-tdis
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.cancel-logoff
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.zerobytelength
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.zerobyteread
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.unlock
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.multiple-unlock
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.stacking
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.contend
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.context
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lock.truncate
- # smb2 leases test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.request
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.nobreakself
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.statopen
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.statopen2
-# - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.statopen3
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.upgrade
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.upgrade2
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.upgrade3
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.break
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.oplock
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.multibreak
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking1
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking2
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking3
-# - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking4
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking5
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.breaking6
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.lock1
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.complex1
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.timeout
-# - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.lease.unlink
- # smb2 acls test
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.CREATOR
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.GENERIC
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.OWNER
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.INHERITANCE
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.INHERITFLAGS
- - sudo rm -rf /mnt/test3/*
- - ./bin/smbtorture //127.0.0.1/cifsd-test3/ -Utestuser%1234 smb2.acls.DYNAMIC
diff --git a/.travis_cmd_wrapper.pl b/.travis_cmd_wrapper.pl
deleted file mode 100755
index 0cbaea4..0000000
--- a/.travis_cmd_wrapper.pl
+++ /dev/null
@@ -1,65 +0,0 @@
-#!/usr/bin/perl
-
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-#
-# Copyright (C) 2019 Samsung Electronics Co., Ltd.
-#
-
-use strict;
-
-sub tweak_sysctl()
-{
-	`sudo sysctl kernel.hardlockup_panic=0`;
-	`sudo sysctl kernel.hung_task_panic=0`;
-	`sudo sysctl kernel.panic=128`;
-	`sudo sysctl kernel.panic_on_io_nmi=0`;
-	`sudo sysctl kernel.panic_on_oops=0`;
-	`sudo sysctl kernel.panic_on_rcu_stall=0`;
-	`sudo sysctl kernel.panic_on_unrecovered_nmi=0`;
-	`sudo sysctl kernel.panic_on_warn=0`;
-	`sudo sysctl kernel.softlockup_panic=0`;
-	`sudo sysctl kernel.unknown_nmi_panic=0`;
-}
-
-sub execute($$)
-{
-	my $cmd = shift;
-	my $timeout = shift;
-	my $output = "Timeout";
-	my $status = 1;
-
-	$timeout = 8 * 60 if (!defined $timeout);
-
-	tweak_sysctl();
-
-	eval {
-		local $SIG{ALRM} = sub {
-			print "TIMEOUT:\n";
-			system("top -n 1"), print "top\n";
-			system("free"), print "free\n";
-			system("dmesg"), print "dmesg\n";
-			die "Timeout\n";
-		};
-
-		print "Executing $cmd with timeout $timeout\n";
-
-		alarm $timeout;
-		$output = `$cmd`;
-		$status = $?;
-		alarm 0;
-		print $output."\n";
-		print "Finished: status $status\n";
-	};
-
-	if ($@) {
-		die unless $@ eq "Timeout\n";
-	}
-}
-
-if (! defined $ARGV[0]) {
-	print "Usage:\n\t./.travis_cmd_wrapper.pl command [timeout seconds]\n";
-	exit 1;
-}
-
-execute($ARGV[0], $ARGV[1]);
diff --git a/.travis_get_mainline_kernel b/.travis_get_mainline_kernel
deleted file mode 100755
index 3356d15..0000000
--- a/.travis_get_mainline_kernel
+++ /dev/null
@@ -1,37 +0,0 @@
-#!/bin/sh
-
-#
-# A simple script we are using to get the latest mainline kernel
-# tar ball
-#
-
-wget https://www.kernel.org/releases.json
-if [ $? -ne 0 ]; then
-	echo "Could not download kernel.org/releases.json"
-	exit 1
-fi
-
-VER=$(cat releases.json | python2.7 -c "import sys, json; print json.load(sys.stdin)['latest_stable']['version']")
-if [ $? -ne 0 ]; then
-	echo "Could not parse release.json"
-	exit 1
-fi
-
-if [ "z$VER" = "z" ]; then
-	echo "Could not determine latest release version"
-	exit 1
-fi
-
-wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-"$VER".tar.gz
-if [ $? -ne 0 ]; then
-	echo "Could not download $VER kernel version"
-	exit 1
-fi
-
-tar xf linux-"$VER".tar.gz
-if [ $? -ne 0 ]; then
-	echo "Could not untar kernel tar ball"
-	exit 1
-fi
-
-mv linux-"$VER" linux
diff --git a/asn1.c b/asn1.c
index b014f46..2276624 100644
--- a/asn1.c
+++ b/asn1.c
@@ -312,9 +312,9 @@ fail:
 	return -EBADMSG;
 }
 
-int ksmbd_neg_token_init_mech_token(void *context, size_t hdrlen,
-				    unsigned char tag, const void *value,
-				    size_t vlen)
+static int ksmbd_neg_token_alloc(void *context, size_t hdrlen,
+				 unsigned char tag, const void *value,
+				 size_t vlen)
 {
 	struct ksmbd_conn *conn = context;
 
@@ -327,17 +327,16 @@ int ksmbd_neg_token_init_mech_token(void *context, size_t hdrlen,
 	return 0;
 }
 
-int ksmbd_neg_token_targ_resp_token(void *context, size_t hdrlen,
+int ksmbd_neg_token_init_mech_token(void *context, size_t hdrlen,
 				    unsigned char tag, const void *value,
 				    size_t vlen)
 {
-	struct ksmbd_conn *conn = context;
-
-	conn->mechToken = kmalloc(vlen + 1, GFP_KERNEL);
-	if (!conn->mechToken)
-		return -ENOMEM;
+	return ksmbd_neg_token_alloc(context, hdrlen, tag, value, vlen);
+}
 
-	memcpy(conn->mechToken, value, vlen);
-	conn->mechToken[vlen] = '\0';
-	return 0;
+int ksmbd_neg_token_targ_resp_token(void *context, size_t hdrlen,
+				    unsigned char tag, const void *value,
+				    size_t vlen)
+{
+	return ksmbd_neg_token_alloc(context, hdrlen, tag, value, vlen);
 }
diff --git a/auth.c b/auth.c
index 992677f..0dbbc48 100644
--- a/auth.c
+++ b/auth.c
@@ -378,22 +378,22 @@ int ksmbd_auth_ntlmv2(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 {
 	char ntlmv2_hash[CIFS_ENCPWD_SIZE];
 	char ntlmv2_rsp[CIFS_HMAC_MD5_HASH_SIZE];
-	struct ksmbd_crypto_ctx *ctx;
+	struct ksmbd_crypto_ctx *ctx = NULL;
 	char *construct = NULL;
 	int rc, len;
 
-	ctx = ksmbd_crypto_ctx_find_hmacmd5();
-	if (!ctx) {
-		ksmbd_debug(AUTH, "could not crypto alloc hmacmd5\n");
-		return -ENOMEM;
-	}
-
 	rc = calc_ntlmv2_hash(conn, sess, ntlmv2_hash, domain_name);
 	if (rc) {
 		ksmbd_debug(AUTH, "could not get v2 hash rc %d\n", rc);
 		goto out;
 	}
 
+	ctx = ksmbd_crypto_ctx_find_hmacmd5();
+	if (!ctx) {
+		ksmbd_debug(AUTH, "could not crypto alloc hmacmd5\n");
+		return -ENOMEM;
+	}
+
 	rc = crypto_shash_setkey(CRYPTO_HMACMD5_TFM(ctx),
 				 ntlmv2_hash,
 				 CIFS_HMAC_MD5_HASH_SIZE);
@@ -429,6 +429,8 @@ int ksmbd_auth_ntlmv2(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 		ksmbd_debug(AUTH, "Could not generate md5 hash\n");
 		goto out;
 	}
+	ksmbd_release_crypto_ctx(ctx);
+	ctx = NULL;
 
 	rc = ksmbd_gen_sess_key(sess, ntlmv2_hash, ntlmv2_rsp);
 	if (rc) {
@@ -439,7 +441,8 @@ int ksmbd_auth_ntlmv2(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 	if (memcmp(ntlmv2->ntlmv2_hash, ntlmv2_rsp, CIFS_HMAC_MD5_HASH_SIZE) != 0)
 		rc = -EINVAL;
 out:
-	ksmbd_release_crypto_ctx(ctx);
+	if (ctx)
+		ksmbd_release_crypto_ctx(ctx);
 	kfree(construct);
 	return rc;
 }
@@ -583,7 +586,8 @@ int ksmbd_decode_ntlmssp_auth_blob(struct authenticate_message *authblob,
 	dn_off = le32_to_cpu(authblob->DomainName.BufferOffset);
 	dn_len = le16_to_cpu(authblob->DomainName.Length);
 
-	if (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len)
+	if (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len ||
+	    nt_len < CIFS_ENCPWD_SIZE)
 		return -EINVAL;
 
 #ifdef CONFIG_SMB_INSECURE_SERVER
@@ -1065,8 +1069,9 @@ static int generate_key(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 		goto smb3signkey_ret;
 	}
 
-	if (conn->cipher_type == SMB2_ENCRYPTION_AES256_CCM ||
-	    conn->cipher_type == SMB2_ENCRYPTION_AES256_GCM)
+	if (key_size == SMB3_ENC_DEC_KEY_SIZE &&
+	    (conn->cipher_type == SMB2_ENCRYPTION_AES256_CCM ||
+	     conn->cipher_type == SMB2_ENCRYPTION_AES256_GCM))
 		rc = crypto_shash_update(CRYPTO_HMACSHA256(ctx), L256, 4);
 	else
 		rc = crypto_shash_update(CRYPTO_HMACSHA256(ctx), L128, 4);
diff --git a/connection.c b/connection.c
index 3911298..4b9665f 100644
--- a/connection.c
+++ b/connection.c
@@ -23,7 +23,7 @@ static DEFINE_MUTEX(init_lock);
 static struct ksmbd_conn_ops default_conn_ops;
 
 LIST_HEAD(conn_list);
-DEFINE_RWLOCK(conn_list_lock);
+DECLARE_RWSEM(conn_list_lock);
 
 /**
  * ksmbd_conn_free() - free resources of the connection instance
@@ -35,9 +35,9 @@ DEFINE_RWLOCK(conn_list_lock);
  */
 void ksmbd_conn_free(struct ksmbd_conn *conn)
 {
-	write_lock(&conn_list_lock);
+	down_write(&conn_list_lock);
 	list_del(&conn->conns_list);
-	write_unlock(&conn_list_lock);
+	up_write(&conn_list_lock);
 
 	xa_destroy(&conn->sessions);
 	kvfree(conn->request_buf);
@@ -59,7 +59,7 @@ struct ksmbd_conn *ksmbd_conn_alloc(void)
 		return NULL;
 
 	conn->need_neg = true;
-	conn->status = KSMBD_SESS_NEW;
+	ksmbd_conn_set_new(conn);
 	conn->local_nls = load_nls("utf8");
 	if (!conn->local_nls)
 		conn->local_nls = load_nls_default();
@@ -91,9 +91,9 @@ struct ksmbd_conn *ksmbd_conn_alloc(void)
 	spin_lock_init(&conn->llist_lock);
 	INIT_LIST_HEAD(&conn->lock_list);
 
-	write_lock(&conn_list_lock);
+	down_write(&conn_list_lock);
 	list_add(&conn->conns_list, &conn_list);
-	write_unlock(&conn_list_lock);
+	up_write(&conn_list_lock);
 	return conn;
 }
 
@@ -102,7 +102,7 @@ bool ksmbd_conn_lookup_dialect(struct ksmbd_conn *c)
 	struct ksmbd_conn *t;
 	bool ret = false;
 
-	read_lock(&conn_list_lock);
+	down_read(&conn_list_lock);
 	list_for_each_entry(t, &conn_list, conns_list) {
 		if (memcmp(t->ClientGUID, c->ClientGUID, SMB2_CLIENT_GUID_SIZE))
 			continue;
@@ -110,7 +110,7 @@ bool ksmbd_conn_lookup_dialect(struct ksmbd_conn *c)
 		ret = true;
 		break;
 	}
-	read_unlock(&conn_list_lock);
+	up_read(&conn_list_lock);
 	return ret;
 }
 
@@ -122,19 +122,15 @@ void ksmbd_conn_enqueue_request(struct ksmbd_work *work)
 	struct smb2_hdr *hdr = work->request_buf;
 
 	if (hdr->ProtocolId == SMB2_PROTO_NUMBER) {
-		if (conn->ops->get_cmd_val(work) != SMB2_CANCEL_HE) {
+		if (conn->ops->get_cmd_val(work) != SMB2_CANCEL_HE)
 			requests_queue = &conn->requests;
-			work->syncronous = true;
-		}
 	} else {
 		if (conn->ops->get_cmd_val(work) != SMB_COM_NT_CANCEL)
 			requests_queue = &conn->requests;
 	}
 #else
-	if (conn->ops->get_cmd_val(work) != SMB2_CANCEL_HE) {
+	if (conn->ops->get_cmd_val(work) != SMB2_CANCEL_HE)
 		requests_queue = &conn->requests;
-		work->syncronous = true;
-	}
 #endif
 
 	if (requests_queue) {
@@ -156,32 +152,60 @@ int ksmbd_conn_try_dequeue_request(struct ksmbd_work *work)
 
 	if (!work->multiRsp)
 		atomic_dec(&conn->req_running);
-	spin_lock(&conn->request_lock);
 	if (!work->multiRsp) {
+		spin_lock(&conn->request_lock);
 		list_del_init(&work->request_entry);
-		if (work->syncronous == false)
-			list_del_init(&work->async_request_entry);
+		spin_unlock(&conn->request_lock);
+		if (work->asynchronous)
+			release_async_work(work);
 		ret = 0;
 	}
-	spin_unlock(&conn->request_lock);
 
 	wake_up_all(&conn->req_running_q);
 	return ret;
 }
 
-static void ksmbd_conn_lock(struct ksmbd_conn *conn)
+void ksmbd_conn_lock(struct ksmbd_conn *conn)
 {
 	mutex_lock(&conn->srv_mutex);
 }
 
-static void ksmbd_conn_unlock(struct ksmbd_conn *conn)
+void ksmbd_conn_unlock(struct ksmbd_conn *conn)
 {
 	mutex_unlock(&conn->srv_mutex);
 }
 
-void ksmbd_conn_wait_idle(struct ksmbd_conn *conn)
+void ksmbd_all_conn_set_status(u64 sess_id, u32 status)
+{
+	struct ksmbd_conn *conn;
+
+	down_read(&conn_list_lock);
+	list_for_each_entry(conn, &conn_list, conns_list) {
+		if (conn->binding || xa_load(&conn->sessions, sess_id))
+			WRITE_ONCE(conn->status, status);
+	}
+	up_read(&conn_list_lock);
+}
+
+void ksmbd_conn_wait_idle(struct ksmbd_conn *conn, u64 sess_id)
 {
+	struct ksmbd_conn *bind_conn;
+
 	wait_event(conn->req_running_q, atomic_read(&conn->req_running) < 2);
+
+	down_read(&conn_list_lock);
+	list_for_each_entry(bind_conn, &conn_list, conns_list) {
+		if (bind_conn == conn)
+			continue;
+
+		if ((bind_conn->binding || xa_load(&bind_conn->sessions, sess_id)) &&
+		    !ksmbd_conn_releasing(bind_conn) &&
+		    atomic_read(&bind_conn->req_running)) {
+			wait_event(bind_conn->req_running_q,
+				atomic_read(&bind_conn->req_running) == 0);
+		}
+	}
+	up_read(&conn_list_lock);
 }
 
 int ksmbd_conn_write(struct ksmbd_work *work)
@@ -265,7 +289,7 @@ bool ksmbd_conn_alive(struct ksmbd_conn *conn)
 	if (!ksmbd_server_running())
 		return false;
 
-	if (conn->status == KSMBD_SESS_EXITING)
+	if (ksmbd_conn_exiting(conn))
 		return false;
 
 	if (kthread_should_stop())
@@ -300,7 +324,7 @@ int ksmbd_conn_handler_loop(void *p)
 {
 	struct ksmbd_conn *conn = (struct ksmbd_conn *)p;
 	struct ksmbd_transport *t = conn->transport;
-	unsigned int pdu_size;
+	unsigned int pdu_size, max_allowed_pdu_size;
 	char hdr_buf[4] = {0,};
 	int size;
 
@@ -318,28 +342,38 @@ int ksmbd_conn_handler_loop(void *p)
 		kvfree(conn->request_buf);
 		conn->request_buf = NULL;
 
-		size = t->ops->read(t, hdr_buf, sizeof(hdr_buf));
+		size = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1);
 		if (size != sizeof(hdr_buf))
 			break;
 
 		pdu_size = get_rfc1002_len(hdr_buf);
 		ksmbd_debug(CONN, "RFC1002 header %u bytes\n", pdu_size);
 
-		/* make sure we have enough to get to SMB header end */
-		if (!ksmbd_pdu_size_has_room(pdu_size)) {
-			ksmbd_debug(CONN, "SMB request too short (%u bytes)\n",
-				    pdu_size);
-			continue;
+		if (ksmbd_conn_good(conn))
+			max_allowed_pdu_size =
+				SMB3_MAX_MSGSIZE + conn->vals->max_write_size;
+		else
+			max_allowed_pdu_size = SMB3_MAX_MSGSIZE;
+
+		if (pdu_size > max_allowed_pdu_size) {
+			pr_err_ratelimited("PDU length(%u) excceed maximum allowed pdu size(%u) on connection(%d)\n",
+					pdu_size, max_allowed_pdu_size,
+					READ_ONCE(conn->status));
+			break;
 		}
 
+		/*
+		 * Check maximum pdu size(0x00FFFFFF).
+		 */
 		if (pdu_size > MAX_STREAM_PROT_LEN)
-                        continue;
+			break;
 
 		/* 4 for rfc1002 length field */
-		size = pdu_size + 4;
+		/* 1 for implied bcc[0] */
+		size = pdu_size + 4 + 1;
 		conn->request_buf = kvmalloc(size, GFP_KERNEL);
 		if (!conn->request_buf)
-			continue;
+			break;
 
 		memcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf));
 		if (!ksmbd_smb_request(conn))
@@ -349,7 +383,7 @@ int ksmbd_conn_handler_loop(void *p)
 		 * We already read 4 bytes to find out PDU size, now
 		 * read in PDU
 		 */
-		size = t->ops->read(t, conn->request_buf + 4, pdu_size);
+		size = t->ops->read(t, conn->request_buf + 4, pdu_size, 2);
 		if (size < 0) {
 			pr_err("sock_read failed: %d\n", size);
 			break;
@@ -373,10 +407,10 @@ int ksmbd_conn_handler_loop(void *p)
 	}
 
 out:
+	ksmbd_conn_set_releasing(conn);
 	/* Wait till all reference dropped to the Server object*/
 	wait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0);
 
-
 	if (IS_ENABLED(CONFIG_UNICODE))
 		utf8_unload(conn->um);
 	unload_nls(conn->local_nls);
@@ -420,7 +454,7 @@ static void stop_sessions(void)
 	struct ksmbd_transport *t;
 
 again:
-	read_lock(&conn_list_lock);
+	down_read(&conn_list_lock);
 	list_for_each_entry(conn, &conn_list, conns_list) {
 		struct task_struct *task;
 
@@ -429,14 +463,14 @@ again:
 		if (task)
 			ksmbd_debug(CONN, "Stop session handler %s/%d\n",
 				    task->comm, task_pid_nr(task));
-		conn->status = KSMBD_SESS_EXITING;
+		ksmbd_conn_set_exiting(conn);
 		if (t->ops->shutdown) {
-			read_unlock(&conn_list_lock);
+			up_read(&conn_list_lock);
 			t->ops->shutdown(t);
-			read_lock(&conn_list_lock);
+			down_read(&conn_list_lock);
 		}
 	}
-	read_unlock(&conn_list_lock);
+	up_read(&conn_list_lock);
 
 	if (!list_empty(&conn_list)) {
 		schedule_timeout_interruptible(HZ / 10); /* 100ms */
diff --git a/connection.h b/connection.h
index 3643354..ad8dfaa 100644
--- a/connection.h
+++ b/connection.h
@@ -26,7 +26,8 @@ enum {
 	KSMBD_SESS_GOOD,
 	KSMBD_SESS_EXITING,
 	KSMBD_SESS_NEED_RECONNECT,
-	KSMBD_SESS_NEED_NEGOTIATE
+	KSMBD_SESS_NEED_NEGOTIATE,
+	KSMBD_SESS_RELEASING
 };
 
 struct ksmbd_stats {
@@ -114,7 +115,8 @@ struct ksmbd_transport_ops {
 	int (*prepare)(struct ksmbd_transport *t);
 	void (*disconnect)(struct ksmbd_transport *t);
 	void (*shutdown)(struct ksmbd_transport *t);
-	int (*read)(struct ksmbd_transport *t, char *buf, unsigned int size);
+	int (*read)(struct ksmbd_transport *t, char *buf,
+		    unsigned int size, int max_retries);
 	int (*writev)(struct ksmbd_transport *t, struct kvec *iovs, int niov,
 		      int size, bool need_invalidate_rkey,
 		      unsigned int remote_key);
@@ -139,10 +141,10 @@ struct ksmbd_transport {
 #define KSMBD_TCP_PEER_SOCKADDR(c)	((struct sockaddr *)&((c)->peer_addr))
 
 extern struct list_head conn_list;
-extern rwlock_t conn_list_lock;
+extern struct rw_semaphore conn_list_lock;
 
 bool ksmbd_conn_alive(struct ksmbd_conn *conn);
-void ksmbd_conn_wait_idle(struct ksmbd_conn *conn);
+void ksmbd_conn_wait_idle(struct ksmbd_conn *conn, u64 sess_id);
 struct ksmbd_conn *ksmbd_conn_alloc(void);
 void ksmbd_conn_free(struct ksmbd_conn *conn);
 bool ksmbd_conn_lookup_dialect(struct ksmbd_conn *c);
@@ -161,6 +163,8 @@ void ksmbd_conn_init_server_callbacks(struct ksmbd_conn_ops *ops);
 int ksmbd_conn_handler_loop(void *p);
 int ksmbd_conn_transport_init(void);
 void ksmbd_conn_transport_destroy(void);
+void ksmbd_conn_lock(struct ksmbd_conn *conn);
+void ksmbd_conn_unlock(struct ksmbd_conn *conn);
 
 /*
  * WARNING
@@ -168,43 +172,60 @@ void ksmbd_conn_transport_destroy(void);
  * This is a hack. We will move status to a proper place once we land
  * a multi-sessions support.
  */
-static inline bool ksmbd_conn_good(struct ksmbd_work *work)
+static inline bool ksmbd_conn_good(struct ksmbd_conn *conn)
 {
-	return work->conn->status == KSMBD_SESS_GOOD;
+	return READ_ONCE(conn->status) == KSMBD_SESS_GOOD;
 }
 
-static inline bool ksmbd_conn_need_negotiate(struct ksmbd_work *work)
+static inline bool ksmbd_conn_need_negotiate(struct ksmbd_conn *conn)
 {
-	return work->conn->status == KSMBD_SESS_NEED_NEGOTIATE;
+	return READ_ONCE(conn->status) == KSMBD_SESS_NEED_NEGOTIATE;
 }
 
-static inline bool ksmbd_conn_need_reconnect(struct ksmbd_work *work)
+static inline bool ksmbd_conn_need_reconnect(struct ksmbd_conn *conn)
 {
-	return work->conn->status == KSMBD_SESS_NEED_RECONNECT;
+	return READ_ONCE(conn->status) == KSMBD_SESS_NEED_RECONNECT;
 }
 
-static inline bool ksmbd_conn_exiting(struct ksmbd_work *work)
+static inline bool ksmbd_conn_exiting(struct ksmbd_conn *conn)
 {
-	return work->conn->status == KSMBD_SESS_EXITING;
+	return READ_ONCE(conn->status) == KSMBD_SESS_EXITING;
 }
 
-static inline void ksmbd_conn_set_good(struct ksmbd_work *work)
+static inline bool ksmbd_conn_releasing(struct ksmbd_conn *conn)
 {
-	work->conn->status = KSMBD_SESS_GOOD;
+	return READ_ONCE(conn->status) == KSMBD_SESS_RELEASING;
 }
 
-static inline void ksmbd_conn_set_need_negotiate(struct ksmbd_work *work)
+static inline void ksmbd_conn_set_new(struct ksmbd_conn *conn)
 {
-	work->conn->status = KSMBD_SESS_NEED_NEGOTIATE;
+	WRITE_ONCE(conn->status, KSMBD_SESS_NEW);
 }
 
-static inline void ksmbd_conn_set_need_reconnect(struct ksmbd_work *work)
+static inline void ksmbd_conn_set_good(struct ksmbd_conn *conn)
 {
-	work->conn->status = KSMBD_SESS_NEED_RECONNECT;
+	WRITE_ONCE(conn->status, KSMBD_SESS_GOOD);
 }
 
-static inline void ksmbd_conn_set_exiting(struct ksmbd_work *work)
+static inline void ksmbd_conn_set_need_negotiate(struct ksmbd_conn *conn)
 {
-	work->conn->status = KSMBD_SESS_EXITING;
+	WRITE_ONCE(conn->status, KSMBD_SESS_NEED_NEGOTIATE);
 }
+
+static inline void ksmbd_conn_set_need_reconnect(struct ksmbd_conn *conn)
+{
+	WRITE_ONCE(conn->status, KSMBD_SESS_NEED_RECONNECT);
+}
+
+static inline void ksmbd_conn_set_exiting(struct ksmbd_conn *conn)
+{
+	WRITE_ONCE(conn->status, KSMBD_SESS_EXITING);
+}
+
+static inline void ksmbd_conn_set_releasing(struct ksmbd_conn *conn)
+{
+	WRITE_ONCE(conn->status, KSMBD_SESS_RELEASING);
+}
+
+void ksmbd_all_conn_set_status(u64 sess_id, u32 status);
 #endif /* __CONNECTION_H__ */
diff --git a/glob.h b/glob.h
index 784e2f0..9bbd904 100644
--- a/glob.h
+++ b/glob.h
@@ -12,7 +12,7 @@
 #include "unicode.h"
 #include "vfs_cache.h"
 
-#define KSMBD_VERSION	"3.4.6"
+#define KSMBD_VERSION	"3.4.8"
 
 extern int ksmbd_debug_types;
 
diff --git a/ksmbd_netlink.h b/ksmbd_netlink.h
index 8feac99..fb96263 100644
--- a/ksmbd_netlink.h
+++ b/ksmbd_netlink.h
@@ -106,7 +106,8 @@ struct ksmbd_startup_request {
 	__u32	sub_auth[3];		/* Subauth value for Security ID */
 	__u32	smb2_max_credits;	/* MAX credits */
 	__u32	smbd_max_io_size;	/* smbd read write size */
-	__u32	reserved[127];		/* Reserved room */
+	__u32	max_connections;	/* Number of maximum simultaneous connections */
+	__u32	reserved[126];		/* Reserved room */
 	__u32	ifc_list_sz;		/* interfaces list size */
 	__s8	____payload[];
 };
diff --git a/ksmbd_work.h b/ksmbd_work.h
index 5ece58e..f8ae614 100644
--- a/ksmbd_work.h
+++ b/ksmbd_work.h
@@ -68,7 +68,7 @@ struct ksmbd_work {
 	/* Request is encrypted */
 	bool                            encrypted:1;
 	/* Is this SYNC or ASYNC ksmbd_work */
-	bool                            syncronous:1;
+	bool                            asynchronous:1;
 	bool                            need_invalidate_rkey:1;
 
 	unsigned int                    remote_key;
diff --git a/mgmt/tree_connect.c b/mgmt/tree_connect.c
index 8ce17b3..408cddf 100644
--- a/mgmt/tree_connect.c
+++ b/mgmt/tree_connect.c
@@ -109,18 +109,15 @@ int ksmbd_tree_conn_disconnect(struct ksmbd_session *sess,
 struct ksmbd_tree_connect *ksmbd_tree_conn_lookup(struct ksmbd_session *sess,
 						  unsigned int id)
 {
-	return xa_load(&sess->tree_conns, id);
-}
+	struct ksmbd_tree_connect *tcon;
 
-struct ksmbd_share_config *ksmbd_tree_conn_share(struct ksmbd_session *sess,
-						 unsigned int id)
-{
-	struct ksmbd_tree_connect *tc;
+	tcon = xa_load(&sess->tree_conns, id);
+	if (tcon) {
+		if (test_bit(TREE_CONN_EXPIRE, &tcon->status))
+			tcon = NULL;
+	}
 
-	tc = ksmbd_tree_conn_lookup(sess, id);
-	if (tc)
-		return tc->share_conf;
-	return NULL;
+	return tcon;
 }
 
 int ksmbd_tree_conn_session_logoff(struct ksmbd_session *sess)
@@ -129,6 +126,9 @@ int ksmbd_tree_conn_session_logoff(struct ksmbd_session *sess)
 	struct ksmbd_tree_connect *tc;
 	unsigned long id;
 
+	if (!sess)
+		return -EINVAL;
+
 	xa_for_each(&sess->tree_conns, id, tc)
 		ret |= ksmbd_tree_conn_disconnect(sess, tc);
 	xa_destroy(&sess->tree_conns);
diff --git a/mgmt/tree_connect.h b/mgmt/tree_connect.h
index 0f97ddc..562d647 100644
--- a/mgmt/tree_connect.h
+++ b/mgmt/tree_connect.h
@@ -14,6 +14,8 @@ struct ksmbd_share_config;
 struct ksmbd_user;
 struct ksmbd_conn;
 
+#define TREE_CONN_EXPIRE		1
+
 struct ksmbd_tree_connect {
 	int				id;
 
@@ -25,6 +27,7 @@ struct ksmbd_tree_connect {
 
 	int				maximal_access;
 	bool				posix_extensions;
+	unsigned long			status;
 };
 
 struct ksmbd_tree_conn_status {
@@ -50,9 +53,6 @@ int ksmbd_tree_conn_disconnect(struct ksmbd_session *sess,
 struct ksmbd_tree_connect *ksmbd_tree_conn_lookup(struct ksmbd_session *sess,
 						  unsigned int id);
 
-struct ksmbd_share_config *ksmbd_tree_conn_share(struct ksmbd_session *sess,
-						 unsigned int id);
-
 int ksmbd_tree_conn_session_logoff(struct ksmbd_session *sess);
 
 #endif /* __TREE_CONNECT_MANAGEMENT_H__ */
diff --git a/mgmt/user_session.c b/mgmt/user_session.c
index ae1359d..25fb3ee 100644
--- a/mgmt/user_session.c
+++ b/mgmt/user_session.c
@@ -25,20 +25,19 @@ static DECLARE_RWSEM(sessions_table_lock);
 struct ksmbd_session_rpc {
 	int			id;
 	unsigned int		method;
-	struct list_head	list;
 };
 
 static void free_channel_list(struct ksmbd_session *sess)
 {
-	struct channel *chann, *tmp;
+	struct channel *chann;
+	unsigned long index;
 
-	write_lock(&sess->chann_lock);
-	list_for_each_entry_safe(chann, tmp, &sess->ksmbd_chann_list,
-				 chann_list) {
-		list_del(&chann->chann_list);
+	xa_for_each(&sess->ksmbd_chann_list, index, chann) {
+		xa_erase(&sess->ksmbd_chann_list, index);
 		kfree(chann);
 	}
-	write_unlock(&sess->chann_lock);
+
+	xa_destroy(&sess->ksmbd_chann_list);
 }
 
 static void __session_rpc_close(struct ksmbd_session *sess,
@@ -58,15 +57,14 @@ static void __session_rpc_close(struct ksmbd_session *sess,
 static void ksmbd_session_rpc_clear_list(struct ksmbd_session *sess)
 {
 	struct ksmbd_session_rpc *entry;
+	long index;
 
-	while (!list_empty(&sess->rpc_handle_list)) {
-		entry = list_entry(sess->rpc_handle_list.next,
-				   struct ksmbd_session_rpc,
-				   list);
-
-		list_del(&entry->list);
+	xa_for_each(&sess->rpc_handle_list, index, entry) {
+		xa_erase(&sess->rpc_handle_list, index);
 		__session_rpc_close(sess, entry);
 	}
+
+	xa_destroy(&sess->rpc_handle_list);
 }
 
 static int __rpc_method(char *rpc_name)
@@ -102,13 +100,13 @@ int ksmbd_session_rpc_open(struct ksmbd_session *sess, char *rpc_name)
 
 	entry = kzalloc(sizeof(struct ksmbd_session_rpc), GFP_KERNEL);
 	if (!entry)
-		return -EINVAL;
+		return -ENOMEM;
 
-	list_add(&entry->list, &sess->rpc_handle_list);
 	entry->method = method;
 	entry->id = ksmbd_ipc_id_alloc();
 	if (entry->id < 0)
 		goto free_entry;
+	xa_store(&sess->rpc_handle_list, entry->id, entry, GFP_KERNEL);
 
 	resp = ksmbd_rpc_open(sess, entry->id);
 	if (!resp)
@@ -117,9 +115,9 @@ int ksmbd_session_rpc_open(struct ksmbd_session *sess, char *rpc_name)
 	kvfree(resp);
 	return entry->id;
 free_id:
+	xa_erase(&sess->rpc_handle_list, entry->id);
 	ksmbd_rpc_id_free(entry->id);
 free_entry:
-	list_del(&entry->list);
 	kfree(entry);
 	return -EINVAL;
 }
@@ -128,24 +126,17 @@ void ksmbd_session_rpc_close(struct ksmbd_session *sess, int id)
 {
 	struct ksmbd_session_rpc *entry;
 
-	list_for_each_entry(entry, &sess->rpc_handle_list, list) {
-		if (entry->id == id) {
-			list_del(&entry->list);
-			__session_rpc_close(sess, entry);
-			break;
-		}
-	}
+	entry = xa_erase(&sess->rpc_handle_list, id);
+	if (entry)
+		__session_rpc_close(sess, entry);
 }
 
 int ksmbd_session_rpc_method(struct ksmbd_session *sess, int id)
 {
 	struct ksmbd_session_rpc *entry;
 
-	list_for_each_entry(entry, &sess->rpc_handle_list, list) {
-		if (entry->id == id)
-			return entry->method;
-	}
-	return 0;
+	entry = xa_load(&sess->rpc_handle_list, id);
+	return entry ? entry->method : 0;
 }
 
 void ksmbd_session_destroy(struct ksmbd_session *sess)
@@ -153,18 +144,6 @@ void ksmbd_session_destroy(struct ksmbd_session *sess)
 	if (!sess)
 		return;
 
-#ifdef CONFIG_SMB_INSECURE_SERVER
-	if (hash_hashed(&sess->hlist)) {
-		down_write(&sessions_table_lock);
-		hash_del(&sess->hlist);
-		up_write(&sessions_table_lock);
-	}
-#else
-	down_write(&sessions_table_lock);
-	hash_del(&sess->hlist);
-	up_write(&sessions_table_lock);
-#endif
-
 	if (sess->user)
 		ksmbd_free_user(sess->user);
 
@@ -182,76 +161,116 @@ static struct ksmbd_session *__session_lookup(unsigned long long id)
 	struct ksmbd_session *sess;
 
 	hash_for_each_possible(sessions_table, sess, hlist, id) {
-		if (id == sess->id)
+		if (id == sess->id) {
+			sess->last_active = jiffies;
 			return sess;
+		}
 	}
 	return NULL;
 }
 
+static void ksmbd_expire_session(struct ksmbd_conn *conn)
+{
+	unsigned long id;
+	struct ksmbd_session *sess;
+
+	down_write(&sessions_table_lock);
+	xa_for_each(&conn->sessions, id, sess) {
+		if (sess->state != SMB2_SESSION_VALID ||
+		    time_after(jiffies,
+			       sess->last_active + SMB2_SESSION_TIMEOUT)) {
+			xa_erase(&conn->sessions, sess->id);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+			if (hash_hashed(&sess->hlist))
+				hash_del(&sess->hlist);
+#else
+			hash_del(&sess->hlist);
+#endif
+			ksmbd_session_destroy(sess);
+			continue;
+		}
+	}
+	up_write(&sessions_table_lock);
+}
+
 int ksmbd_session_register(struct ksmbd_conn *conn,
 			   struct ksmbd_session *sess)
 {
 	sess->dialect = conn->dialect;
 	memcpy(sess->ClientGUID, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE);
+	ksmbd_expire_session(conn);
 	return xa_err(xa_store(&conn->sessions, sess->id, sess, GFP_KERNEL));
 }
 
 static int ksmbd_chann_del(struct ksmbd_conn *conn, struct ksmbd_session *sess)
 {
-	struct channel *chann, *tmp;
-
-	write_lock(&sess->chann_lock);
-	list_for_each_entry_safe(chann, tmp, &sess->ksmbd_chann_list,
-				 chann_list) {
-		if (chann->conn == conn) {
-			list_del(&chann->chann_list);
-			kfree(chann);
-			write_unlock(&sess->chann_lock);
-			return 0;
-		}
-	}
-	write_unlock(&sess->chann_lock);
+	struct channel *chann;
+
+	chann = xa_erase(&sess->ksmbd_chann_list, (long)conn);
+	if (!chann)
+		return -ENOENT;
 
-	return -ENOENT;
+	kfree(chann);
+	return 0;
 }
 
 void ksmbd_sessions_deregister(struct ksmbd_conn *conn)
 {
 	struct ksmbd_session *sess;
+	unsigned long id;
 
+	down_write(&sessions_table_lock);
 	if (conn->binding) {
 		int bkt;
+		struct hlist_node *tmp;
 
-		down_write(&sessions_table_lock);
-		hash_for_each(sessions_table, bkt, sess, hlist) {
-			if (!ksmbd_chann_del(conn, sess)) {
-				up_write(&sessions_table_lock);
-				goto sess_destroy;
+		hash_for_each_safe(sessions_table, bkt, tmp, sess, hlist) {
+			if (!ksmbd_chann_del(conn, sess) &&
+			    xa_empty(&sess->ksmbd_chann_list)) {
+#ifdef CONFIG_SMB_INSECURE_SERVER
+			if (hash_hashed(&sess->hlist))
+				hash_del(&sess->hlist);
+#else
+				hash_del(&sess->hlist);
+#endif
+				ksmbd_session_destroy(sess);
 			}
 		}
-		up_write(&sessions_table_lock);
-	} else {
-		unsigned long id;
-
-		xa_for_each(&conn->sessions, id, sess) {
-			if (!ksmbd_chann_del(conn, sess))
-				goto sess_destroy;
-		}
 	}
 
-	return;
+	xa_for_each(&conn->sessions, id, sess) {
+		unsigned long chann_id;
+		struct channel *chann;
 
-sess_destroy:
-	if (list_empty(&sess->ksmbd_chann_list)) {
-		xa_erase(&conn->sessions, sess->id);
-		ksmbd_session_destroy(sess);
+		xa_for_each(&sess->ksmbd_chann_list, chann_id, chann) {
+			if (chann->conn != conn)
+				ksmbd_conn_set_exiting(chann->conn);
+		}
+
+		ksmbd_chann_del(conn, sess);
+		if (xa_empty(&sess->ksmbd_chann_list)) {
+			xa_erase(&conn->sessions, sess->id);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+			if (hash_hashed(&sess->hlist))
+				hash_del(&sess->hlist);
+#else
+			hash_del(&sess->hlist);
+#endif
+			ksmbd_session_destroy(sess);
+		}
 	}
+	up_write(&sessions_table_lock);
 }
 
 struct ksmbd_session *ksmbd_session_lookup(struct ksmbd_conn *conn,
 					   unsigned long long id)
 {
-	return xa_load(&conn->sessions, id);
+	struct ksmbd_session *sess;
+
+	sess = xa_load(&conn->sessions, id);
+	if (sess)
+		sess->last_active = jiffies;
+	return sess;
 }
 
 struct ksmbd_session *ksmbd_session_lookup_slowpath(unsigned long long id)
@@ -260,6 +279,8 @@ struct ksmbd_session *ksmbd_session_lookup_slowpath(unsigned long long id)
 
 	down_read(&sessions_table_lock);
 	sess = __session_lookup(id);
+	if (sess)
+		sess->last_active = jiffies;
 	up_read(&sessions_table_lock);
 
 	return sess;
@@ -347,12 +368,13 @@ static struct ksmbd_session *__session_create(int protocol)
 	if (ksmbd_init_file_table(&sess->file_table))
 		goto error;
 
+	sess->last_active = jiffies;
+	sess->state = SMB2_SESSION_IN_PROGRESS;
 	set_session_flag(sess, protocol);
 	xa_init(&sess->tree_conns);
-	INIT_LIST_HEAD(&sess->ksmbd_chann_list);
-	INIT_LIST_HEAD(&sess->rpc_handle_list);
+	xa_init(&sess->ksmbd_chann_list);
+	xa_init(&sess->rpc_handle_list);
 	sess->sequence_number = 1;
-	rwlock_init(&sess->chann_lock);
 
 	switch (protocol) {
 #ifdef CONFIG_SMB_INSECURE_SERVER
diff --git a/mgmt/user_session.h b/mgmt/user_session.h
index 4ba24d4..bbe28be 100644
--- a/mgmt/user_session.h
+++ b/mgmt/user_session.h
@@ -24,7 +24,6 @@ struct ksmbd_file_table;
 struct channel {
 	__u8			smb3signingkey[SMB3_SIGN_KEY_SIZE];
 	struct ksmbd_conn	*conn;
-	struct list_head	chann_list;
 };
 
 struct preauth_session {
@@ -53,17 +52,17 @@ struct ksmbd_session {
 	char				sess_key[CIFS_KEY_SIZE];
 
 	struct hlist_node		hlist;
-	rwlock_t			chann_lock;
-	struct list_head		ksmbd_chann_list;
+	struct xarray			ksmbd_chann_list;
 	struct xarray			tree_conns;
 	struct ida			tree_conn_ida;
-	struct list_head		rpc_handle_list;
+	struct xarray			rpc_handle_list;
 
 	__u8				smb3encryptionkey[SMB3_ENC_DEC_KEY_SIZE];
 	__u8				smb3decryptionkey[SMB3_ENC_DEC_KEY_SIZE];
 	__u8				smb3signingkey[SMB3_SIGN_KEY_SIZE];
 
 	struct ksmbd_file_table		file_table;
+	unsigned long			last_active;
 };
 
 static inline int test_session_flag(struct ksmbd_session *sess, int bit)
diff --git a/ndr.c b/ndr.c
index 5f3c2e8..1630339 100644
--- a/ndr.c
+++ b/ndr.c
@@ -241,7 +241,7 @@ int ndr_decode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da)
 		return ret;
 
 	if (da->version != 3 && da->version != 4) {
-		pr_err("v%d version is not supported\n", da->version);
+		ksmbd_debug(VFS, "v%d version is not supported\n", da->version);
 		return -EINVAL;
 	}
 
@@ -250,7 +250,7 @@ int ndr_decode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da)
 		return ret;
 
 	if (da->version != version2) {
-		pr_err("ndr version mismatched(version: %d, version2: %d)\n",
+		ksmbd_debug(VFS, "ndr version mismatched(version: %d, version2: %d)\n",
 		       da->version, version2);
 		return -EINVAL;
 	}
@@ -337,7 +337,11 @@ static int ndr_encode_posix_acl_entry(struct ndr *n, struct xattr_smb_acl *acl)
 }
 
 int ndr_encode_posix_acl(struct ndr *n,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			 struct mnt_idmap *idmap,
+#else
 			 struct user_namespace *user_ns,
+#endif
 			 struct inode *inode,
 			 struct xattr_smb_acl *acl,
 			 struct xattr_smb_acl *def_acl)
@@ -377,7 +381,11 @@ int ndr_encode_posix_acl(struct ndr *n,
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsuid = i_uid_into_vfsuid(idmap, inode);
+#else
 	vfsuid = i_uid_into_vfsuid(user_ns, inode);
+#endif
 	ret = ndr_write_int64(n, from_kuid(&init_user_ns, vfsuid_into_kuid(vfsuid)));
 #else
 	ret = ndr_write_int64(n, from_kuid(&init_user_ns, i_uid_into_mnt(user_ns, inode)));
@@ -386,7 +394,11 @@ int ndr_encode_posix_acl(struct ndr *n,
 		return ret;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsgid = i_gid_into_vfsgid(idmap, inode);
+#else
 	vfsgid = i_gid_into_vfsgid(user_ns, inode);
+#endif
 	ret = ndr_write_int64(n, from_kgid(&init_user_ns, vfsgid_into_kgid(vfsgid)));
 #else
 	ret = ndr_write_int64(n, from_kgid(&init_user_ns, i_gid_into_mnt(user_ns, inode)));
@@ -477,7 +489,7 @@ int ndr_decode_v4_ntacl(struct ndr *n, struct xattr_ntacl *acl)
 	if (ret)
 		return ret;
 	if (acl->version != 4) {
-		pr_err("v%d version is not supported\n", acl->version);
+		ksmbd_debug(VFS, "v%d version is not supported\n", acl->version);
 		return -EINVAL;
 	}
 
@@ -485,7 +497,7 @@ int ndr_decode_v4_ntacl(struct ndr *n, struct xattr_ntacl *acl)
 	if (ret)
 		return ret;
 	if (acl->version != version2) {
-		pr_err("ndr version mismatched(version: %d, version2: %d)\n",
+		ksmbd_debug(VFS, "ndr version mismatched(version: %d, version2: %d)\n",
 		       acl->version, version2);
 		return -EINVAL;
 	}
diff --git a/ndr.h b/ndr.h
index 60ca265..a300c0f 100644
--- a/ndr.h
+++ b/ndr.h
@@ -14,7 +14,11 @@ struct ndr {
 
 int ndr_encode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da);
 int ndr_decode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ndr_encode_posix_acl(struct ndr *n, struct mnt_idmap *idmap,
+#else
 int ndr_encode_posix_acl(struct ndr *n, struct user_namespace *user_ns,
+#endif
 			 struct inode *inode, struct xattr_smb_acl *acl,
 			 struct xattr_smb_acl *def_acl);
 int ndr_encode_v4_ntacl(struct ndr *n, struct xattr_ntacl *acl);
diff --git a/oplock.c b/oplock.c
index c036167..ee1c895 100644
--- a/oplock.c
+++ b/oplock.c
@@ -862,8 +862,8 @@ static void __smb2_oplock_break_noti(struct work_struct *wk)
 		rsp->OplockLevel = SMB2_OPLOCK_LEVEL_NONE;
 	rsp->Reserved = 0;
 	rsp->Reserved2 = 0;
-	rsp->PersistentFid = cpu_to_le64(fp->persistent_id);
-	rsp->VolatileFid = cpu_to_le64(fp->volatile_id);
+	rsp->PersistentFid = fp->persistent_id;
+	rsp->VolatileFid = fp->volatile_id;
 
 	inc_rfc1001_len(work->response_buf, 24);
 
@@ -1747,7 +1747,7 @@ struct create_context *smb2_find_context_vals(void *open_req, const char *tag)
 			return ERR_PTR(-EINVAL);
 
 		name = (char *)cc + name_off;
-		if (memcmp(name, tag, name_len) == 0)
+		if (!strcmp(name, tag))
 			return cc;
 
 		remain_len -= next;
@@ -1863,12 +1863,18 @@ void create_posix_rsp_buf(char *cc, struct ksmbd_file *fp)
 {
 	struct create_posix_rsp *buf;
 	struct inode *inode = file_inode(fp->filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(fp->filp);
+	vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);
+	vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);
+#else
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 	struct user_namespace *user_ns = file_mnt_user_ns(fp->filp);
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	vfsuid_t vfsuid = i_uid_into_vfsuid(user_ns, inode);
 	vfsgid_t vfsgid = i_gid_into_vfsgid(user_ns, inode);
+#endif
 #endif
 
 	buf = (struct create_posix_rsp *)cc;
diff --git a/server.c b/server.c
index faab095..a730869 100644
--- a/server.c
+++ b/server.c
@@ -93,7 +93,8 @@ static inline int check_conn_state(struct ksmbd_work *work)
 {
 	struct smb_hdr *rsp_hdr;
 
-	if (ksmbd_conn_exiting(work) || ksmbd_conn_need_reconnect(work)) {
+	if (ksmbd_conn_exiting(work->conn) ||
+	    ksmbd_conn_need_reconnect(work->conn)) {
 		rsp_hdr = work->response_buf;
 		rsp_hdr->Status.CifsError = STATUS_CONNECTION_DISCONNECTED;
 		return 1;
@@ -289,10 +290,7 @@ static int queue_ksmbd_work(struct ksmbd_conn *conn)
 	work->request_buf = conn->request_buf;
 	conn->request_buf = NULL;
 
-	if (ksmbd_init_smb_server(work)) {
-		ksmbd_free_work_struct(work);
-		return -EINVAL;
-	}
+	ksmbd_init_smb_server(work);
 
 	ksmbd_conn_enqueue_request(work);
 	atomic_inc(&conn->r_count);
@@ -418,7 +416,11 @@ int server_queue_ctrl_reset_work(void)
 	return __queue_ctrl_work(SERVER_CTRL_TYPE_RESET);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static ssize_t stats_show(const struct class *class, const struct class_attribute *attr,
+#else
 static ssize_t stats_show(struct class *class, struct class_attribute *attr,
+#endif
 			  char *buf)
 {
 	/*
@@ -437,8 +439,13 @@ static ssize_t stats_show(struct class *class, struct class_attribute *attr,
 			  server_conf.ipc_last_active / HZ);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static ssize_t kill_server_store(const struct class *class,
+				 const struct class_attribute *attr, const char *buf,
+#else
 static ssize_t kill_server_store(struct class *class,
 				 struct class_attribute *attr, const char *buf,
+#endif
 				 size_t len)
 {
 	if (!sysfs_streq(buf, "hard"))
@@ -458,7 +465,11 @@ static const char * const debug_type_strings[] = {"smb", "auth", "vfs",
 						  "oplock", "ipc", "conn",
 						  "rdma"};
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static ssize_t debug_show(const struct class *class, const struct class_attribute *attr,
+#else
 static ssize_t debug_show(struct class *class, struct class_attribute *attr,
+#endif
 			  char *buf)
 {
 	ssize_t sz = 0;
@@ -476,7 +487,11 @@ static ssize_t debug_show(struct class *class, struct class_attribute *attr,
 	return sz;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static ssize_t debug_store(const struct class *class, const struct class_attribute *attr,
+#else
 static ssize_t debug_store(struct class *class, struct class_attribute *attr,
+#endif
 			   const char *buf, size_t len)
 {
 	int i;
@@ -516,7 +531,9 @@ ATTRIBUTE_GROUPS(ksmbd_control_class);
 
 static struct class ksmbd_control_class = {
 	.name		= "ksmbd-control",
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
 	.owner		= THIS_MODULE,
+#endif
 	.class_groups	= ksmbd_control_class_groups,
 };
 
@@ -606,6 +623,7 @@ err_unregister:
 static void __exit ksmbd_server_exit(void)
 {
 	ksmbd_server_shutdown();
+	rcu_barrier();
 	ksmbd_release_inode_hash();
 }
 
diff --git a/server.h b/server.h
index ac9d932..db72781 100644
--- a/server.h
+++ b/server.h
@@ -41,6 +41,7 @@ struct ksmbd_server_config {
 	unsigned int		share_fake_fscaps;
 	struct smb_sid		domain_sid;
 	unsigned int		auth_mechs;
+	unsigned int		max_connections;
 
 	char			*conf[SERVER_CONF_WORK_GROUP + 1];
 };
diff --git a/smb1ops.c b/smb1ops.c
index b1e2aac..26b27b9 100644
--- a/smb1ops.c
+++ b/smb1ops.c
@@ -80,14 +80,10 @@ static struct smb_version_cmds smb1_server_cmds[256] = {
  *			command dispatcher
  * @conn:	connection instance
  */
-int init_smb1_server(struct ksmbd_conn *conn)
+void init_smb1_server(struct ksmbd_conn *conn)
 {
-	if (!conn)
-		return -EINVAL;
-
 	conn->vals = &smb1_server_values;
 	conn->ops = &smb1_server_ops;
 	conn->cmds = smb1_server_cmds;
 	conn->max_cmds = ARRAY_SIZE(smb1_server_cmds);
-	return 0;
 }
diff --git a/smb1pdu.c b/smb1pdu.c
index 3cb092d..bf5817d 100644
--- a/smb1pdu.c
+++ b/smb1pdu.c
@@ -253,12 +253,12 @@ int smb_check_user_session(struct ksmbd_work *work)
 		cmd == SMB_COM_ECHO)
 		return 0;
 
-	if (!ksmbd_conn_good(work))
+	if (!ksmbd_conn_good(conn))
 		return -EINVAL;
 
 	if (xa_empty(&conn->sessions)) {
 		ksmbd_debug(SMB, "NO sessions registered\n");
-		return 0;
+		return -EINVAL;
 	}
 
 	work->sess = ksmbd_session_lookup(conn, le16_to_cpu(req_hdr->Uid));
@@ -317,12 +317,9 @@ int smb_session_disconnect(struct ksmbd_work *work)
 	struct ksmbd_session *sess = work->sess;
 
 	/* setting CifsExiting here may race with start_tcp_sess */
-	ksmbd_conn_set_need_reconnect(work);
-
-	ksmbd_free_user(sess->user);
-	sess->user = NULL;
+	ksmbd_conn_set_need_reconnect(conn);
 
-	ksmbd_conn_wait_idle(conn);
+	ksmbd_conn_wait_idle(conn, sess->id);
 
 	ksmbd_tree_conn_session_logoff(sess);
 	xa_erase(&conn->sessions, sess->id);
@@ -330,7 +327,7 @@ int smb_session_disconnect(struct ksmbd_work *work)
 	work->sess = NULL;
 
 	/* let start_tcp_sess free conn info now */
-	ksmbd_conn_set_exiting(work);
+	ksmbd_conn_set_exiting(conn);
 	return 0;
 }
 
@@ -820,7 +817,7 @@ int smb_handle_negotiate(struct ksmbd_work *work)
 	__u64 time;
 	int rc = 0;
 
-	WARN_ON(ksmbd_conn_good(work));
+	WARN_ON(ksmbd_conn_good(conn));
 
 	if (conn->dialect == BAD_PROT_ID) {
 		neg_rsp->hdr.Status.CifsError = STATUS_INVALID_LOGON_TYPE;
@@ -883,7 +880,7 @@ int smb_handle_negotiate(struct ksmbd_work *work)
 
 	/* Null terminated domain name in unicode */
 
-	ksmbd_conn_set_need_negotiate(work);
+	ksmbd_conn_set_need_negotiate(conn);
 	/* Domain name and PC name are ignored by clients, so no need to send.
 	 * We can try sending them later
 	 */
@@ -1267,7 +1264,7 @@ int smb_session_setup_andx(struct ksmbd_work *work)
 		goto out_err;
 
 	work->sess = sess;
-	ksmbd_conn_set_good(work);
+	ksmbd_conn_set_good(conn);
 	return 0;
 
 out_err:
@@ -1678,7 +1675,7 @@ int smb_locking_andx(struct ksmbd_work *work)
 
 		list_del(&smb_lock->llist);
 		/* check locks in connections */
-		read_lock(&conn_list_lock);
+		down_read(&conn_list_lock);
 		list_for_each_entry(conn, &conn_list, conns_list) {
 			spin_lock(&conn->llist_lock);
 			list_for_each_entry_safe(cmp_lock, tmp2, &conn->lock_list, clist) {
@@ -1691,7 +1688,7 @@ int smb_locking_andx(struct ksmbd_work *work)
 					cmp_lock->end == smb_lock->end) {
 					same_zero_lock = 1;
 					spin_unlock(&conn->llist_lock);
-					read_unlock(&conn_list_lock);
+					up_read(&conn_list_lock);
 					goto out_check_cl;
 				}
 
@@ -1732,7 +1729,7 @@ int smb_locking_andx(struct ksmbd_work *work)
 						smb_lock->start >= 0xEF000000)) {
 						if (timeout) {
 							spin_unlock(&conn->llist_lock);
-							read_unlock(&conn_list_lock);
+							up_read(&conn_list_lock);
 							ksmbd_debug(SMB, "waiting error response for timeout : %d\n",
 								timeout);
 							msleep(timeout);
@@ -1747,14 +1744,14 @@ int smb_locking_andx(struct ksmbd_work *work)
 
 					if (timeout <= 0) {
 						spin_unlock(&conn->llist_lock);
-						read_unlock(&conn_list_lock);
+						up_read(&conn_list_lock);
 					}
 					goto out;
 				}
 			}
 			spin_unlock(&conn->llist_lock);
 		}
-		read_unlock(&conn_list_lock);
+		up_read(&conn_list_lock);
 
 out_check_cl:
 		if (same_zero_lock)
@@ -1847,7 +1844,7 @@ skip:
 			flock->fl_end = offset + length;
 
 		locked = 0;
-		read_lock(&conn_list_lock);
+		up_read(&conn_list_lock);
 		list_for_each_entry(conn, &conn_list, conns_list) {
 			spin_lock(&conn->llist_lock);
 			list_for_each_entry(cmp_lock, &conn->lock_list, clist) {
@@ -1859,13 +1856,13 @@ skip:
 					 cmp_lock->end == offset + length)) {
 					locked = 1;
 					spin_unlock(&conn->llist_lock);
-					read_unlock(&conn_list_lock);
+					up_read(&conn_list_lock);
 					goto out_check_cl_unlck;
 				}
 			}
 			spin_unlock(&conn->llist_lock);
 		}
-		read_unlock(&conn_list_lock);
+		up_read(&conn_list_lock);
 
 out_check_cl_unlck:
 		if (!locked) {
@@ -5891,7 +5888,11 @@ static int ksmbd_fill_dirent(struct dir_context *ctx, const char *name, int naml
 
 	reclen = ALIGN(sizeof(struct ksmbd_dirent) + namlen, sizeof(u64));
 	if (buf->used + reclen > PAGE_SIZE)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
+		return false;
+#else
 		return -EINVAL;
+#endif
 
 	de->namelen = namlen;
 	de->offset = offset;
@@ -5900,7 +5901,11 @@ static int ksmbd_fill_dirent(struct dir_context *ctx, const char *name, int naml
 	memcpy(de->name, name, namlen);
 	buf->used += reclen;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
+	return true;
+#else
 	return 0;
+#endif
 }
 
 /**
diff --git a/smb1pdu.h b/smb1pdu.h
index fb6c395..e470c8e 100644
--- a/smb1pdu.h
+++ b/smb1pdu.h
@@ -178,6 +178,33 @@
 /* Action bits */
 #define GUEST_LOGIN 1
 
+struct smb_negotiate_rsp {
+	struct smb_hdr hdr;     /* wct = 17 */
+	__le16 DialectIndex; /* 0xFFFF = no dialect acceptable */
+	__u8 SecurityMode;
+	__le16 MaxMpxCount;
+	__le16 MaxNumberVcs;
+	__le32 MaxBufferSize;
+	__le32 MaxRawSize;
+	__le32 SessionKey;
+	__le32 Capabilities;    /* see below */
+	__le32 SystemTimeLow;
+	__le32 SystemTimeHigh;
+	__le16 ServerTimeZone;
+	__u8 EncryptionKeyLength;
+	__le16 ByteCount;
+	union {
+		unsigned char EncryptionKey[8]; /* cap extended security off */
+		/* followed by Domain name - if extended security is off */
+		/* followed by 16 bytes of server GUID */
+		/* then security blob if cap_extended_security negotiated */
+		struct {
+			unsigned char GUID[SMB1_CLIENT_GUID_SIZE];
+			unsigned char SecurityBlob[1];
+		} __packed extended_response;
+	} __packed u;
+} __packed;
+
 struct smb_com_read_req {
 	struct smb_hdr hdr;     /* wct = 12 */
 	__u8 AndXCommand;
@@ -1554,7 +1581,9 @@ struct smb_com_setattr_rsp {
 	__le16 ByteCount;        /* bct = 0 */
 } __packed;
 
-extern int init_smb1_server(struct ksmbd_conn *conn);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+extern void init_smb1_server(struct ksmbd_conn *conn);
+#endif
 
 /* function prototypes */
 extern int init_smb_rsp_hdr(struct ksmbd_work *work);
@@ -1571,7 +1600,9 @@ extern int ksmbd_smb1_check_message(struct ksmbd_work *work);
 /* smb1 command handlers */
 extern int smb_rename(struct ksmbd_work *work);
 extern int smb_negotiate_request(struct ksmbd_work *work);
+#ifdef CONFIG_SMB_INSECURE_SERVER
 extern int smb_handle_negotiate(struct ksmbd_work *work);
+#endif
 extern int smb_session_setup_andx(struct ksmbd_work *work);
 extern int smb_tree_connect_andx(struct ksmbd_work *work);
 extern int smb_trans2(struct ksmbd_work *work);
diff --git a/smb2misc.c b/smb2misc.c
index de500b2..dc09d81 100644
--- a/smb2misc.c
+++ b/smb2misc.c
@@ -150,15 +150,11 @@ static int smb2_get_data_area_len(unsigned int *off, unsigned int *len,
 		break;
 	case SMB2_LOCK:
 	{
-		int lock_count;
+		unsigned short lock_count;
 
-		/*
-		 * smb2_lock request size is 48 included single
-		 * smb2_lock_element structure size.
-		 */
-		lock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount) - 1;
+		lock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount);
 		if (lock_count > 0) {
-			*off = __SMB2_HEADER_STRUCTURE_SIZE + 48;
+			*off = offsetof(struct smb2_lock_req, locks);
 			*len = sizeof(struct smb2_lock_element) * lock_count;
 		}
 		break;
@@ -413,20 +409,22 @@ int ksmbd_smb2_check_message(struct ksmbd_work *work)
 			goto validate_credit;
 
 		/*
-		 * windows client also pad up to 8 bytes when compounding.
-		 * If pad is longer than eight bytes, log the server behavior
-		 * (once), since may indicate a problem but allow it and
-		 * continue since the frame is parseable.
+		 * SMB2 NEGOTIATE request will be validated when message
+		 * handling proceeds.
 		 */
-		if (clc_len < len) {
-			ksmbd_debug(SMB,
-				    "cli req padded more than expected. Length %d not %d for cmd:%d mid:%llu\n",
-				    len, clc_len, command,
-				    le64_to_cpu(hdr->MessageId));
+		if (command == SMB2_NEGOTIATE_HE)
+			goto validate_credit;
+
+		/*
+		 * Allow a message that padded to 8byte boundary.
+		 * Linux 4.19.217 with smb 3.0.2 are sometimes
+		 * sending messages where the cls_len is exactly
+		 * 8 bytes less than len.
+		 */
+		if (clc_len < len && (len - clc_len) <= 8)
 			goto validate_credit;
-		}
 
-		ksmbd_debug(SMB,
+		pr_err_ratelimited(
 			    "cli req too short, len %d not %d. cmd:%d mid:%llu\n",
 			    len, clc_len, command,
 			    le64_to_cpu(hdr->MessageId));
diff --git a/smb2pdu.c b/smb2pdu.c
index 0ecd6cd..6cf001f 100644
--- a/smb2pdu.c
+++ b/smb2pdu.c
@@ -13,6 +13,10 @@
 #include <linux/falloc.h>
 #include <linux/crc32.h>
 #include <linux/mount.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#include <linux/filelock.h>
+#endif
 
 #include "glob.h"
 #include "smb2pdu.h"
@@ -76,14 +80,7 @@ static inline bool check_session_id(struct ksmbd_conn *conn, u64 id)
 
 struct channel *lookup_chann_list(struct ksmbd_session *sess, struct ksmbd_conn *conn)
 {
-	struct channel *chann;
-
-	list_for_each_entry(chann, &sess->ksmbd_chann_list, chann_list) {
-		if (chann->conn == conn)
-			return chann;
-	}
-
-	return NULL;
+	return xa_load(&sess->ksmbd_chann_list, (long)conn);
 }
 
 /**
@@ -237,12 +234,6 @@ int init_smb2_neg_rsp(struct ksmbd_work *work)
 	struct smb2_negotiate_rsp *rsp;
 	struct ksmbd_conn *conn = work->conn;
 
-	if (conn->need_neg == false)
-		return -EINVAL;
-	if (!(conn->dialect >= SMB20_PROT_ID &&
-	      conn->dialect <= SMB311_PROT_ID))
-		return -EINVAL;
-
 	*(__be32 *)work->response_buf =
 		cpu_to_be32(conn->vals->header_size);
 
@@ -262,7 +253,7 @@ int init_smb2_neg_rsp(struct ksmbd_work *work)
 
 	rsp = smb2_get_msg(work->response_buf);
 
-	WARN_ON(ksmbd_conn_good(work));
+	WARN_ON(ksmbd_conn_good(conn));
 
 	rsp->StructureSize = cpu_to_le16(65);
 	ksmbd_debug(SMB, "conn->dialect 0x%x\n", conn->dialect);
@@ -292,7 +283,7 @@ int init_smb2_neg_rsp(struct ksmbd_work *work)
 		rsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;
 	conn->use_spnego = true;
 
-	ksmbd_conn_set_need_negotiate(work);
+	ksmbd_conn_set_need_negotiate(conn);
 	return 0;
 }
 
@@ -341,13 +332,9 @@ int smb2_set_rsp_credits(struct ksmbd_work *work)
 	if (hdr->Command == SMB2_NEGOTIATE)
 		aux_max = 1;
 	else
-		aux_max = conn->vals->max_credits - credit_charge;
+		aux_max = conn->vals->max_credits - conn->total_credits;
 	credits_granted = min_t(unsigned short, credits_requested, aux_max);
 
-	if (conn->vals->max_credits - conn->total_credits < credits_granted)
-		credits_granted = conn->vals->max_credits -
-			conn->total_credits;
-
 	conn->total_credits += credits_granted;
 	work->credits_granted += credits_granted;
 
@@ -510,12 +497,6 @@ int init_smb2_rsp_hdr(struct ksmbd_work *work)
 	rsp_hdr->SessionId = rcv_hdr->SessionId;
 	memcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);
 
-	work->syncronous = true;
-	if (work->async_id) {
-		ksmbd_release_id(&conn->async_ida, work->async_id);
-		work->async_id = 0;
-	}
-
 	return 0;
 }
 
@@ -582,7 +563,7 @@ int smb2_check_user_session(struct ksmbd_work *work)
 	    cmd == SMB2_SESSION_SETUP_HE)
 		return 0;
 
-	if (!ksmbd_conn_good(work))
+	if (!ksmbd_conn_good(conn))
 		return -EINVAL;
 
 	sess_id = le64_to_cpu(req_hdr->SessionId);
@@ -600,6 +581,7 @@ static void destroy_previous_session(struct ksmbd_conn *conn,
 	struct ksmbd_session *prev_sess = ksmbd_session_lookup_slowpath(id);
 	struct ksmbd_user *prev_user;
 	struct channel *chann;
+	long index;
 
 	if (!prev_sess)
 		return;
@@ -613,10 +595,8 @@ static void destroy_previous_session(struct ksmbd_conn *conn,
 		return;
 
 	prev_sess->state = SMB2_SESSION_EXPIRED;
-	write_lock(&prev_sess->chann_lock);
-	list_for_each_entry(chann, &prev_sess->ksmbd_chann_list, chann_list)
-		chann->conn->status = KSMBD_SESS_EXITING;
-	write_unlock(&prev_sess->chann_lock);
+	xa_for_each(&prev_sess->ksmbd_chann_list, index, chann)
+		ksmbd_conn_set_exiting(chann->conn);
 }
 
 /**
@@ -659,7 +639,7 @@ int setup_async_work(struct ksmbd_work *work, void (*fn)(void **), void **arg)
 		pr_err("Failed to alloc async message id\n");
 		return id;
 	}
-	work->syncronous = false;
+	work->asynchronous = true;
 	work->async_id = id;
 	rsp_hdr->Id.AsyncId = cpu_to_le64(id);
 
@@ -679,6 +659,24 @@ int setup_async_work(struct ksmbd_work *work, void (*fn)(void **), void **arg)
 	return 0;
 }
 
+void release_async_work(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+
+	spin_lock(&conn->request_lock);
+	list_del_init(&work->async_request_entry);
+	spin_unlock(&conn->request_lock);
+
+	work->asynchronous = 0;
+	work->cancel_fn = NULL;
+	kfree(work->cancel_argv);
+	work->cancel_argv = NULL;
+	if (work->async_id) {
+		ksmbd_release_id(&conn->async_ida, work->async_id);
+		work->async_id = 0;
+	}
+}
+
 void smb2_send_interim_resp(struct ksmbd_work *work, __le32 status)
 {
 	struct smb2_hdr *rsp_hdr;
@@ -762,19 +760,6 @@ static void build_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt,
 	pneg_ctxt->Ciphers[0] = cipher_type;
 }
 
-static void build_compression_ctxt(struct smb2_compression_ctx *pneg_ctxt,
-				   __le16 comp_algo)
-{
-	pneg_ctxt->ContextType = SMB2_COMPRESSION_CAPABILITIES;
-	pneg_ctxt->DataLength =
-		cpu_to_le16(sizeof(struct smb2_compression_ctx)
-			- sizeof(struct smb2_neg_context));
-	pneg_ctxt->Reserved = cpu_to_le32(0);
-	pneg_ctxt->CompressionAlgorithmCount = cpu_to_le16(1);
-	pneg_ctxt->Reserved1 = cpu_to_le32(0);
-	pneg_ctxt->CompressionAlgorithms[0] = comp_algo;
-}
-
 static void build_sign_cap_ctxt(struct smb2_signing_capabilities *pneg_ctxt,
 				__le16 sign_algo)
 {
@@ -814,7 +799,7 @@ static void assemble_neg_contexts(struct ksmbd_conn *conn,
 				  struct smb2_negotiate_rsp *rsp,
 				  void *smb2_buf_len)
 {
-	char *pneg_ctxt = (char *)rsp +
+	char * const pneg_ctxt = (char *)rsp +
 			le32_to_cpu(rsp->NegotiateContextOffset);
 	int neg_ctxt_cnt = 1;
 	int ctxt_size;
@@ -823,61 +808,46 @@ static void assemble_neg_contexts(struct ksmbd_conn *conn,
 		    "assemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\n");
 	build_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt,
 			   conn->preauth_info->Preauth_HashId);
-	rsp->NegotiateContextCount = cpu_to_le16(neg_ctxt_cnt);
 	inc_rfc1001_len(smb2_buf_len, AUTH_GSS_PADDING);
 	ctxt_size = sizeof(struct smb2_preauth_neg_context);
-	/* Round to 8 byte boundary */
-	pneg_ctxt += round_up(sizeof(struct smb2_preauth_neg_context), 8);
 
 	if (conn->cipher_type) {
+		/* Round to 8 byte boundary */
 		ctxt_size = round_up(ctxt_size, 8);
 		ksmbd_debug(SMB,
 			    "assemble SMB2_ENCRYPTION_CAPABILITIES context\n");
-		build_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt,
+		build_encrypt_ctxt((struct smb2_encryption_neg_context *)
+				   (pneg_ctxt + ctxt_size),
 				   conn->cipher_type);
-		rsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);
+		neg_ctxt_cnt++;
 		ctxt_size += sizeof(struct smb2_encryption_neg_context) + 2;
-		/* Round to 8 byte boundary */
-		pneg_ctxt +=
-			round_up(sizeof(struct smb2_encryption_neg_context) + 2,
-				 8);
 	}
 
-	if (conn->compress_algorithm) {
-		ctxt_size = round_up(ctxt_size, 8);
-		ksmbd_debug(SMB,
-			    "assemble SMB2_COMPRESSION_CAPABILITIES context\n");
-		/* Temporarily set to SMB3_COMPRESS_NONE */
-		build_compression_ctxt((struct smb2_compression_ctx *)pneg_ctxt,
-				       conn->compress_algorithm);
-		rsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);
-		ctxt_size += sizeof(struct smb2_compression_ctx) + 2;
-		/* Round to 8 byte boundary */
-		pneg_ctxt += round_up(sizeof(struct smb2_compression_ctx) + 2,
-				      8);
-	}
+	/* compression context not yet supported */
+	WARN_ON(conn->compress_algorithm != SMB3_COMPRESS_NONE);
 
 	if (conn->posix_ext_supported) {
 		ctxt_size = round_up(ctxt_size, 8);
 		ksmbd_debug(SMB,
 			    "assemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\n");
-		build_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);
-		rsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);
+		build_posix_ctxt((struct smb2_posix_neg_context *)
+				 (pneg_ctxt + ctxt_size));
+		neg_ctxt_cnt++;
 		ctxt_size += sizeof(struct smb2_posix_neg_context);
-		/* Round to 8 byte boundary */
-		pneg_ctxt += round_up(sizeof(struct smb2_posix_neg_context), 8);
 	}
 
 	if (conn->signing_negotiated) {
 		ctxt_size = round_up(ctxt_size, 8);
 		ksmbd_debug(SMB,
 			    "assemble SMB2_SIGNING_CAPABILITIES context\n");
-		build_sign_cap_ctxt((struct smb2_signing_capabilities *)pneg_ctxt,
+		build_sign_cap_ctxt((struct smb2_signing_capabilities *)
+				    (pneg_ctxt + ctxt_size),
 				    conn->signing_algorithm);
-		rsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);
+		neg_ctxt_cnt++;
 		ctxt_size += sizeof(struct smb2_signing_capabilities) + 2;
 	}
 
+	rsp->NegotiateContextCount = cpu_to_le16(neg_ctxt_cnt);
 	inc_rfc1001_len(smb2_buf_len, ctxt_size);
 }
 
@@ -1080,7 +1050,7 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 
 	ksmbd_debug(SMB, "Received negotiate request\n");
 	conn->need_neg = false;
-	if (ksmbd_conn_good(work)) {
+	if (ksmbd_conn_good(conn)) {
 		pr_err("conn->tcp_status is already in CifsGood State\n");
 		work->send_no_response = 1;
 		return rc;
@@ -1244,7 +1214,7 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 	}
 
 	conn->srv_sec_mode = le16_to_cpu(rsp->SecurityMode);
-	ksmbd_conn_set_need_negotiate(work);
+	ksmbd_conn_set_need_negotiate(conn);
 
 err_out:
 	if (rc < 0)
@@ -1395,7 +1365,7 @@ static struct ksmbd_user *session_user(struct ksmbd_conn *conn,
 	struct authenticate_message *authblob;
 	struct ksmbd_user *user;
 	char *name;
-	unsigned int auth_msg_len, name_off, name_len, secbuf_len;
+	unsigned int name_off, name_len, secbuf_len;
 
 	secbuf_len = le16_to_cpu(req->SecurityBufferLength);
 	if (secbuf_len < sizeof(struct authenticate_message)) {
@@ -1405,9 +1375,8 @@ static struct ksmbd_user *session_user(struct ksmbd_conn *conn,
 	authblob = user_authblob(conn, req);
 	name_off = le32_to_cpu(authblob->UserName.BufferOffset);
 	name_len = le16_to_cpu(authblob->UserName.Length);
-	auth_msg_len = le16_to_cpu(req->SecurityBufferOffset) + secbuf_len;
 
-	if (auth_msg_len < (u64)name_off + name_len)
+	if (secbuf_len < (u64)name_off + name_len)
 		return NULL;
 
 	name = smb_strndup_from_utf16((const char *)authblob + name_off,
@@ -1470,7 +1439,7 @@ static int ntlm_authenticate(struct ksmbd_work *work)
 		 * Reuse session if anonymous try to connect
 		 * on reauthetication.
 		 */
-		if (ksmbd_anonymous_user(user)) {
+		if (conn->binding == false && ksmbd_anonymous_user(user)) {
 			ksmbd_free_user(user);
 			return 0;
 		}
@@ -1484,7 +1453,7 @@ static int ntlm_authenticate(struct ksmbd_work *work)
 		sess->user = user;
 	}
 
-	if (user_guest(sess->user)) {
+	if (conn->binding == false && user_guest(sess->user)) {
 		rsp->SessionFlags = SMB2_SESSION_FLAG_IS_GUEST_LE;
 	} else {
 		struct authenticate_message *authblob;
@@ -1535,19 +1504,14 @@ static int ntlm_authenticate(struct ksmbd_work *work)
 
 binding_session:
 	if (conn->dialect >= SMB30_PROT_ID) {
-		read_lock(&sess->chann_lock);
 		chann = lookup_chann_list(sess, conn);
-		read_unlock(&sess->chann_lock);
 		if (!chann) {
 			chann = kmalloc(sizeof(struct channel), GFP_KERNEL);
 			if (!chann)
 				return -ENOMEM;
 
 			chann->conn = conn;
-			INIT_LIST_HEAD(&chann->chann_list);
-			write_lock(&sess->chann_lock);
-			list_add(&chann->chann_list, &sess->ksmbd_chann_list);
-			write_unlock(&sess->chann_lock);
+			xa_store(&sess->ksmbd_chann_list, (long)conn, chann, GFP_KERNEL);
 		}
 	}
 
@@ -1624,19 +1588,14 @@ static int krb5_authenticate(struct ksmbd_work *work)
 	}
 
 	if (conn->dialect >= SMB30_PROT_ID) {
-		read_lock(&sess->chann_lock);
 		chann = lookup_chann_list(sess, conn);
-		read_unlock(&sess->chann_lock);
 		if (!chann) {
 			chann = kmalloc(sizeof(struct channel), GFP_KERNEL);
 			if (!chann)
 				return -ENOMEM;
 
 			chann->conn = conn;
-			INIT_LIST_HEAD(&chann->chann_list);
-			write_lock(&sess->chann_lock);
-			list_add(&chann->chann_list, &sess->ksmbd_chann_list);
-			write_unlock(&sess->chann_lock);
+			xa_store(&sess->ksmbd_chann_list, (long)conn, chann, GFP_KERNEL);
 		}
 	}
 
@@ -1681,6 +1640,7 @@ int smb2_sess_setup(struct ksmbd_work *work)
 	rsp->SecurityBufferLength = 0;
 	inc_rfc1001_len(work->response_buf, 9);
 
+	ksmbd_conn_lock(conn);
 	if (!req->hdr.SessionId) {
 		sess = ksmbd_smb2_session_create();
 		if (!sess) {
@@ -1728,11 +1688,22 @@ int smb2_sess_setup(struct ksmbd_work *work)
 			goto out_err;
 		}
 
+		if (ksmbd_conn_need_reconnect(conn)) {
+			rc = -EFAULT;
+			sess = NULL;
+			goto out_err;
+		}
+
 		if (ksmbd_session_lookup(conn, sess_id)) {
 			rc = -EACCES;
 			goto out_err;
 		}
 
+		if (user_guest(sess->user)) {
+			rc = -EOPNOTSUPP;
+			goto out_err;
+		}
+
 		conn->binding = true;
 	} else if ((conn->dialect < SMB30_PROT_ID ||
 		    server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&
@@ -1747,12 +1718,20 @@ int smb2_sess_setup(struct ksmbd_work *work)
 			rc = -ENOENT;
 			goto out_err;
 		}
+
+		if (sess->state == SMB2_SESSION_EXPIRED) {
+			rc = -EFAULT;
+			goto out_err;
+		}
+
+		if (ksmbd_conn_need_reconnect(conn)) {
+			rc = -EFAULT;
+			sess = NULL;
+			goto out_err;
+		}
 	}
 	work->sess = sess;
 
-	if (sess->state == SMB2_SESSION_EXPIRED)
-		sess->state = SMB2_SESSION_IN_PROGRESS;
-
 	negblob_off = le16_to_cpu(req->SecurityBufferOffset);
 	negblob_len = le16_to_cpu(req->SecurityBufferLength);
 	if (negblob_off < offsetof(struct smb2_sess_setup_req, Buffer) ||
@@ -1782,8 +1761,10 @@ int smb2_sess_setup(struct ksmbd_work *work)
 				goto out_err;
 			}
 
-			ksmbd_conn_set_good(work);
-			sess->state = SMB2_SESSION_VALID;
+			if (!ksmbd_conn_need_reconnect(conn)) {
+				ksmbd_conn_set_good(conn);
+				sess->state = SMB2_SESSION_VALID;
+			}
 			kfree(sess->Preauth_HashValue);
 			sess->Preauth_HashValue = NULL;
 		} else if (conn->preferred_auth_mech == KSMBD_AUTH_NTLMSSP) {
@@ -1805,8 +1786,10 @@ int smb2_sess_setup(struct ksmbd_work *work)
 				if (rc)
 					goto out_err;
 
-				ksmbd_conn_set_good(work);
-				sess->state = SMB2_SESSION_VALID;
+				if (!ksmbd_conn_need_reconnect(conn)) {
+					ksmbd_conn_set_good(conn);
+					sess->state = SMB2_SESSION_VALID;
+				}
 				if (conn->binding) {
 					struct preauth_session *preauth_sess;
 
@@ -1819,6 +1802,10 @@ int smb2_sess_setup(struct ksmbd_work *work)
 				}
 				kfree(sess->Preauth_HashValue);
 				sess->Preauth_HashValue = NULL;
+			} else {
+				pr_info_ratelimited("Unknown NTLMSSP message type : 0x%x\n",
+						le32_to_cpu(negblob->MessageType));
+				rc = -EINVAL;
 			}
 		} else {
 			/* TODO: need one more negotiation */
@@ -1841,6 +1828,8 @@ out_err:
 		rsp->hdr.Status = STATUS_NETWORK_SESSION_EXPIRED;
 	else if (rc == -ENOMEM)
 		rsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;
+	else if (rc == -EOPNOTSUPP)
+		rsp->hdr.Status = STATUS_NOT_SUPPORTED;
 	else if (rc)
 		rsp->hdr.Status = STATUS_LOGON_FAILURE;
 
@@ -1868,14 +1857,17 @@ out_err:
 			if (sess->user && sess->user->flags & KSMBD_USER_FLAG_DELAY_SESSION)
 				try_delay = true;
 
-			xa_erase(&conn->sessions, sess->id);
-			ksmbd_session_destroy(sess);
-			work->sess = NULL;
-			if (try_delay)
+			sess->last_active = jiffies;
+			sess->state = SMB2_SESSION_EXPIRED;
+			if (try_delay) {
+				ksmbd_conn_set_need_reconnect(conn);
 				ssleep(5);
+				ksmbd_conn_set_need_negotiate(conn);
+			}
 		}
 	}
 
+	ksmbd_conn_unlock(conn);
 	return rc;
 }
 
@@ -1948,13 +1940,13 @@ int smb2_tree_connect(struct ksmbd_work *work)
 	if (conn->posix_ext_supported)
 		status.tree_conn->posix_extensions = true;
 
-out_err1:
 	rsp->StructureSize = cpu_to_le16(16);
+	inc_rfc1001_len(work->response_buf, 16);
+out_err1:
 	rsp->Capabilities = 0;
 	rsp->Reserved = 0;
 	/* default manual caching */
 	rsp->ShareFlags = SMB2_SHAREFLAG_MANUAL_CACHING;
-	inc_rfc1001_len(work->response_buf, 16);
 
 	if (!IS_ERR(treename))
 		kfree(treename);
@@ -1987,6 +1979,9 @@ out_err1:
 		rsp->hdr.Status = STATUS_ACCESS_DENIED;
 	}
 
+	if (status.ret != KSMBD_TREE_CONN_STATUS_OK)
+		smb2_set_err_rsp(work);
+
 	return rc;
 }
 
@@ -2070,11 +2065,12 @@ int smb2_tree_disconnect(struct ksmbd_work *work)
 
 	ksmbd_debug(SMB, "request\n");
 
-	if (!tcon) {
+	if (!tcon || test_and_set_bit(TREE_CONN_EXPIRE, &tcon->status)) {
 		struct smb2_tree_disconnect_req *req =
 			smb2_get_msg(work->request_buf);
 
 		ksmbd_debug(SMB, "Invalid tid %d\n", req->hdr.Id.SyncId.TreeId);
+
 		rsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;
 		smb2_set_err_rsp(work);
 		return 0;
@@ -2096,21 +2092,25 @@ int smb2_session_logoff(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
 	struct smb2_logoff_rsp *rsp = smb2_get_msg(work->response_buf);
-	struct ksmbd_session *sess = work->sess;
+	struct ksmbd_session *sess;
+	struct smb2_logoff_req *req = smb2_get_msg(work->request_buf);
+	u64 sess_id = le64_to_cpu(req->hdr.SessionId);
 
 	rsp->StructureSize = cpu_to_le16(4);
 	inc_rfc1001_len(work->response_buf, 4);
 
 	ksmbd_debug(SMB, "request\n");
 
-	/* setting CifsExiting here may race with start_tcp_sess */
-	ksmbd_conn_set_need_reconnect(work);
+	ksmbd_all_conn_set_status(sess_id, KSMBD_SESS_NEED_RECONNECT);
 	ksmbd_close_session_fds(work);
-	ksmbd_conn_wait_idle(conn);
+	ksmbd_conn_wait_idle(conn, sess_id);
 
+	/*
+	 * Re-lookup session to validate if session is deleted
+	 * while waiting request complete
+	 */
+	sess = ksmbd_session_lookup_all(conn, sess_id);
 	if (ksmbd_tree_conn_session_logoff(sess)) {
-		struct smb2_logoff_req *req = smb2_get_msg(work->request_buf);
-
 		ksmbd_debug(SMB, "Invalid tid %d\n", req->hdr.Id.SyncId.TreeId);
 		rsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;
 		smb2_set_err_rsp(work);
@@ -2122,9 +2122,7 @@ int smb2_session_logoff(struct ksmbd_work *work)
 
 	ksmbd_free_user(sess->user);
 	sess->user = NULL;
-
-	/* let start_tcp_sess free connection info now */
-	ksmbd_conn_set_need_negotiate(work);
+	ksmbd_all_conn_set_status(sess_id, KSMBD_SESS_NEED_NEGOTIATE);
 	return 0;
 }
 
@@ -2209,7 +2207,11 @@ out:
 static int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,
 		       const struct path *path)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	char *attr_name = NULL, *value;
 	int rc = 0;
 	unsigned int next = 0;
@@ -2245,7 +2247,11 @@ static int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,
 		value = (char *)&eabuf->name + eabuf->EaNameLength + 1;
 
 		if (!eabuf->EaValueLength) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			rc = ksmbd_vfs_casexattr_len(idmap,
+#else
 			rc = ksmbd_vfs_casexattr_len(user_ns,
+#endif
 						     path->dentry,
 						     attr_name,
 						     XATTR_USER_PREFIX_LEN +
@@ -2253,7 +2259,11 @@ static int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,
 
 			/* delete the EA only when it exits */
 			if (rc > 0) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+				rc = ksmbd_vfs_remove_xattr(idmap,
+#else
 				rc = ksmbd_vfs_remove_xattr(user_ns,
+#endif
 							    path->dentry,
 							    attr_name);
 
@@ -2268,7 +2278,11 @@ static int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,
 			/* if the EA doesn't exist, just do nothing. */
 			rc = 0;
 		} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			rc = ksmbd_vfs_setxattr(idmap,
+#else
 			rc = ksmbd_vfs_setxattr(user_ns,
+#endif
 						path->dentry, attr_name, value,
 						le16_to_cpu(eabuf->EaValueLength), 0);
 			if (rc < 0) {
@@ -2298,7 +2312,11 @@ static noinline int smb2_set_stream_name_xattr(const struct path *path,
 					       struct ksmbd_file *fp,
 					       char *stream_name, int s_type)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	size_t xattr_stream_size;
 	char *xattr_stream_name;
 	int rc;
@@ -2314,7 +2332,11 @@ static noinline int smb2_set_stream_name_xattr(const struct path *path,
 	fp->stream.size = xattr_stream_size;
 
 	/* Check if there is stream prefix in xattr space */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_casexattr_len(idmap,
+#else
 	rc = ksmbd_vfs_casexattr_len(user_ns,
+#endif
 				     path->dentry,
 				     xattr_stream_name,
 				     xattr_stream_size);
@@ -2326,7 +2348,11 @@ static noinline int smb2_set_stream_name_xattr(const struct path *path,
 		return -EBADF;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_setxattr(idmap, path->dentry,
+#else
 	rc = ksmbd_vfs_setxattr(user_ns, path->dentry,
+#endif
 				xattr_stream_name, NULL, 0, 0);
 	if (rc < 0)
 		pr_err("Failed to store XATTR stream name :%d\n", rc);
@@ -2335,7 +2361,11 @@ static noinline int smb2_set_stream_name_xattr(const struct path *path,
 
 static int smb2_remove_smb_xattrs(const struct path *path)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	char *name, *xattr_list = NULL;
 	ssize_t xattr_list_len;
 	int err = 0;
@@ -2355,8 +2385,13 @@ static int smb2_remove_smb_xattrs(const struct path *path)
 		if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&
 		    !strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX,
 			     STREAM_PREFIX_LEN)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			err = ksmbd_vfs_remove_xattr(idmap, path->dentry,
+						     name);
+#else
 			err = ksmbd_vfs_remove_xattr(user_ns, path->dentry,
 						     name);
+#endif
 			if (err)
 				ksmbd_debug(SMB, "remove xattr failed : %s\n",
 					    name);
@@ -2402,8 +2437,13 @@ static void smb2_new_xattrs(struct ksmbd_tree_connect *tcon, const struct path *
 	da.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |
 		XATTR_DOSINFO_ITIME;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_set_dos_attrib_xattr(mnt_idmap(path->mnt),
+					    path->dentry, &da);
+#else
 	rc = ksmbd_vfs_set_dos_attrib_xattr(mnt_user_ns(path->mnt),
 					    path->dentry, &da);
+#endif
 	if (rc)
 		ksmbd_debug(SMB, "failed to store file attribute into xattr\n");
 }
@@ -2421,8 +2461,13 @@ static void smb2_update_xattrs(struct ksmbd_tree_connect *tcon,
 				    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))
 		return;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_get_dos_attrib_xattr(mnt_idmap(path->mnt),
+					    path->dentry, &da);
+#else
 	rc = ksmbd_vfs_get_dos_attrib_xattr(mnt_user_ns(path->mnt),
 					    path->dentry, &da);
+#endif
 	if (rc > 0) {
 		fp->f_ci->m_fattr = cpu_to_le32(da.attr);
 		fp->create_time = da.create_time;
@@ -2496,13 +2541,22 @@ static int smb2_create_sd_buffer(struct ksmbd_work *work,
 }
 
 static void ksmbd_acls_fattr(struct smb_fattr *fattr,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			     struct mnt_idmap *idmap,
+#else
 			     struct user_namespace *mnt_userns,
+#endif
 			     struct inode *inode)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);
+	vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);
+#else
 	vfsuid_t vfsuid = i_uid_into_vfsuid(mnt_userns, inode);
 	vfsgid_t vfsgid = i_gid_into_vfsgid(mnt_userns, inode);
+#endif
 
 	fattr->cf_uid = vfsuid_into_kuid(vfsuid);
 	fattr->cf_gid = vfsgid_into_kgid(vfsgid);
@@ -2519,9 +2573,17 @@ static void ksmbd_acls_fattr(struct smb_fattr *fattr,
 	fattr->cf_dacls = NULL;
 
 	if (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+		fattr->cf_acls = get_inode_acl(inode, ACL_TYPE_ACCESS);
+#else
 		fattr->cf_acls = get_acl(inode, ACL_TYPE_ACCESS);
+#endif
 		if (S_ISDIR(inode->i_mode))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+			fattr->cf_dacls = get_inode_acl(inode, ACL_TYPE_DEFAULT);
+#else
 			fattr->cf_dacls = get_acl(inode, ACL_TYPE_DEFAULT);
+#endif
 	}
 }
 
@@ -2542,7 +2604,11 @@ int smb2_open(struct ksmbd_work *work)
 	struct ksmbd_share_config *share = tcon->share_conf;
 	struct ksmbd_file *fp = NULL;
 	struct file *filp = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = NULL;
+#else
 	struct user_namespace *user_ns = NULL;
+#endif
 	struct kstat stat;
 	struct create_context *context;
 	struct lease_ctx_info *lc = NULL;
@@ -2797,7 +2863,11 @@ int smb2_open(struct ksmbd_work *work)
 	} else {
 		file_present = true;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		idmap = mnt_idmap(path.mnt);
+#else
 		user_ns = mnt_user_ns(path.mnt);
+#endif
 #else
 		user_ns = NULL;
 #endif
@@ -2863,7 +2933,11 @@ int smb2_open(struct ksmbd_work *work)
 		if (!file_present) {
 			daccess = cpu_to_le32(GENERIC_ALL_FLAGS);
 		} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			rc = ksmbd_vfs_query_maximal_access(idmap,
+#else
 			rc = ksmbd_vfs_query_maximal_access(user_ns,
+#endif
 							    path.dentry,
 							    &daccess);
 			if (rc)
@@ -2899,7 +2973,11 @@ int smb2_open(struct ksmbd_work *work)
 		}
 
 		created = true;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		idmap = mnt_idmap(path.mnt);
+#else
 		user_ns = mnt_user_ns(path.mnt);
+#endif
 		if (ea_buf) {
 			if (le32_to_cpu(ea_buf->ccontext.DataLength) <
 			    sizeof(struct smb2_ea_info)) {
@@ -2922,7 +3000,11 @@ int smb2_open(struct ksmbd_work *work)
 		 */
 		if (daccess & ~(FILE_READ_ATTRIBUTES_LE | FILE_READ_CONTROL_LE)) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			rc = inode_permission(idmap,
+#else
 			rc = inode_permission(user_ns,
+#endif
 					      d_inode(path.dentry),
 					      may_flags);
 #else
@@ -2933,7 +3015,11 @@ int smb2_open(struct ksmbd_work *work)
 
 			if ((daccess & FILE_DELETE_LE) ||
 			    (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+				rc = ksmbd_vfs_may_delete(idmap,
+#else
 				rc = ksmbd_vfs_may_delete(user_ns,
+#endif
 							  path.dentry);
 				if (rc)
 					goto err_out;
@@ -2996,9 +3082,15 @@ int smb2_open(struct ksmbd_work *work)
 		int posix_acl_rc;
 		struct inode *inode = d_inode(path.dentry);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		posix_acl_rc = ksmbd_vfs_inherit_posix_acl(idmap,
+							   path.dentry,
+							   d_inode(path.dentry->d_parent));
+#else
 		posix_acl_rc = ksmbd_vfs_inherit_posix_acl(user_ns,
-							   inode,
+							   path.dentry,
 							   d_inode(path.dentry->d_parent));
+#endif
 		if (posix_acl_rc)
 			ksmbd_debug(SMB, "inherit posix acl failed : %d\n", posix_acl_rc);
 
@@ -3012,8 +3104,13 @@ int smb2_open(struct ksmbd_work *work)
 			rc = smb2_create_sd_buffer(work, req, &path);
 			if (rc) {
 				if (posix_acl_rc)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					ksmbd_vfs_set_init_posix_acl(idmap,
+								     path.dentry);
+#else
 					ksmbd_vfs_set_init_posix_acl(user_ns,
-								     inode);
+								     path.dentry);
+#endif
 
 				if (test_share_config_flag(work->tcon->share_conf,
 							   KSMBD_SHARE_FLAG_ACL_XATTR)) {
@@ -3021,7 +3118,11 @@ int smb2_open(struct ksmbd_work *work)
 					struct smb_ntsd *pntsd;
 					int pntsd_size, ace_num = 0;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					ksmbd_acls_fattr(&fattr, idmap, inode);
+#else
 					ksmbd_acls_fattr(&fattr, user_ns, inode);
+#endif
 					if (fattr.cf_acls)
 						ace_num = fattr.cf_acls->a_count;
 					if (fattr.cf_dacls)
@@ -3032,10 +3133,17 @@ int smb2_open(struct ksmbd_work *work)
 							sizeof(struct smb_acl) +
 							sizeof(struct smb_ace) * ace_num * 2,
 							GFP_KERNEL);
-					if (!pntsd)
+					if (!pntsd) {
+						posix_acl_release(fattr.cf_acls);
+						posix_acl_release(fattr.cf_dacls);
 						goto err_out;
+					}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					rc = build_sec_desc(idmap,
+#else
 					rc = build_sec_desc(user_ns,
+#endif
 							    pntsd, NULL, 0,
 							    OWNER_SECINFO |
 							    GROUP_SECINFO |
@@ -3049,7 +3157,11 @@ int smb2_open(struct ksmbd_work *work)
 					}
 
 					rc = ksmbd_vfs_set_sd_xattr(conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+								    idmap,
+#else
 								    user_ns,
+#endif
 								    path.dentry,
 								    pntsd,
 								    pntsd_size);
@@ -3245,7 +3357,11 @@ int smb2_open(struct ksmbd_work *work)
 		struct create_context *mxac_ccontext;
 
 		if (maximal_access == 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			ksmbd_vfs_query_maximal_access(idmap,
+#else
 			ksmbd_vfs_query_maximal_access(user_ns,
+#endif
 						       path.dentry,
 						       &maximal_access);
 		mxac_ccontext = (struct create_context *)(rsp->Buffer +
@@ -3669,7 +3785,11 @@ static void unlock_dir(struct ksmbd_file *dir_fp)
 
 static int process_query_dir_entries(struct smb2_query_dir_private *priv)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap	*idmap = file_mnt_idmap(priv->dir_fp->filp);
+#else
 	struct user_namespace	*user_ns = file_mnt_user_ns(priv->dir_fp->filp);
+#endif
 	struct kstat		kstat;
 	struct ksmbd_kstat	ksmbd_kstat;
 	int			rc;
@@ -3683,7 +3803,11 @@ static int process_query_dir_entries(struct smb2_query_dir_private *priv)
 
 		lock_dir(priv->dir_fp);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		dent = lookup_one(idmap, priv->d_info->name,
+#else
 		dent = lookup_one(user_ns, priv->d_info->name,
+#endif
 				  priv->dir_fp->filp->f_path.dentry,
 				  priv->d_info->name_len);
 #else
@@ -3709,7 +3833,12 @@ static int process_query_dir_entries(struct smb2_query_dir_private *priv)
 		ksmbd_kstat.kstat = &kstat;
 		if (priv->info_level != FILE_NAMES_INFORMATION)
 			ksmbd_vfs_fill_dentry_attrs(priv->work,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+						    idmap,
+#else
 						    user_ns,
+#endif
+
 						    dent,
 						    &ksmbd_kstat);
 
@@ -3879,7 +4008,7 @@ static int __query_dir(struct dir_context *ctx, const char *name, int namlen,
 	if (d_info->flags & SMB2_RETURN_SINGLE_ENTRY) {
 		d_info->out_buf_len = 0;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
-		return false;
+		return true;
 #else
 		return 0;
 #endif
@@ -3970,7 +4099,11 @@ int smb2_query_dir(struct ksmbd_work *work)
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 	if (!(dir_fp->daccess & FILE_LIST_DIRECTORY_LE) ||
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	    inode_permission(file_mnt_idmap(dir_fp->filp),
+#else
 	    inode_permission(file_mnt_user_ns(dir_fp->filp),
+#endif
 			     file_inode(dir_fp->filp),
 			     MAY_READ | MAY_EXEC)) {
 #else
@@ -4240,7 +4373,11 @@ static int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,
 	ssize_t buf_free_len, alignment_bytes, next_offset, rsp_data_cnt = 0;
 	struct smb2_ea_info_req *ea_req = NULL;
 	const struct path *path;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(fp->filp);
+#else
 	struct user_namespace *user_ns = file_mnt_user_ns(fp->filp);
+#endif
 
 	if (!(fp->daccess & FILE_READ_EA_LE)) {
 		pr_err("Not permitted to read ext attr : 0x%x\n",
@@ -4320,7 +4457,11 @@ static int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,
 		buf_free_len -= (offsetof(struct smb2_ea_info, name) +
 				name_len + 1);
 		/* bailout if xattr can't fit in buf_free_len */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		value_len = ksmbd_vfs_getxattr(idmap, path->dentry,
+#else
 		value_len = ksmbd_vfs_getxattr(user_ns, path->dentry,
+#endif
 					       name, &buf);
 		if (value_len <= 0) {
 			rc = -ENOENT;
@@ -4411,7 +4552,13 @@ static int get_file_basic_info(struct smb2_query_info_rsp *rsp,
 
 	basic_info = (struct smb2_file_basic_info *)rsp->Buffer;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp), &stat);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), file_inode(fp->filp),
+			 &stat);
+#else
+	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),
+			 &stat);
+#endif
 #else
 	generic_fillattr(file_inode(fp->filp), &stat);
 #endif
@@ -4455,7 +4602,11 @@ static void get_file_standard_info(struct smb2_query_info_rsp *rsp,
 
 	inode = file_inode(fp->filp);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), inode, &stat);
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);
+#endif
 #else
 	generic_fillattr(inode, &stat);
 #endif
@@ -4513,7 +4664,11 @@ static int get_file_all_info(struct ksmbd_work *work,
 
 	inode = file_inode(fp->filp);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), inode, &stat);
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);
+#endif
 #else
 	generic_fillattr(inode, &stat);
 #endif
@@ -4594,7 +4749,13 @@ static void get_file_stream_info(struct ksmbd_work *work,
 	struct smb2_query_info_req *req = ksmbd_req_buf_next(work);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp), &stat);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), file_inode(fp->filp),
+			 &stat);
+#else
+	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),
+			 &stat);
+#endif
 #else
 	generic_fillattr(file_inode(fp->filp), &stat);
 #endif
@@ -4688,7 +4849,13 @@ static void get_file_internal_info(struct smb2_query_info_rsp *rsp,
 	struct kstat stat;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp), &stat);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), file_inode(fp->filp),
+			 &stat);
+#else
+	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),
+			 &stat);
+#endif
 #else
 	generic_fillattr(file_inode(fp->filp), &stat);
 #endif
@@ -4717,7 +4884,11 @@ static int get_file_network_open_info(struct smb2_query_info_rsp *rsp,
 
 	inode = file_inode(fp->filp);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), inode, &stat);
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);
+#endif
 #else
 	generic_fillattr(inode, &stat);
 #endif
@@ -4782,7 +4953,13 @@ static void get_file_compression_info(struct smb2_query_info_rsp *rsp,
 	struct kstat stat;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp), &stat);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), file_inode(fp->filp),
+			 &stat);
+#else
+	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),
+			 &stat);
+#endif
 #else
 	generic_fillattr(file_inode(fp->filp), &stat);
 #endif
@@ -4825,7 +5002,11 @@ static int find_file_posix_info(struct smb2_query_info_rsp *rsp,
 {
 	struct smb311_posix_qinfo *file_info;
 	struct inode *inode = file_inode(fp->filp);
-	u64 time;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(fp->filp);
+	vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);
+	vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);
+#else
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 	struct user_namespace *user_ns = file_mnt_user_ns(fp->filp);
 #endif
@@ -4833,6 +5014,8 @@ static int find_file_posix_info(struct smb2_query_info_rsp *rsp,
 	vfsuid_t vfsuid = i_uid_into_vfsuid(user_ns, inode);
 	vfsgid_t vfsgid = i_gid_into_vfsgid(user_ns, inode);
 #endif
+#endif
+	u64 time;
 	int out_buf_len = sizeof(struct smb311_posix_qinfo) + 32;
 
 	file_info = (struct smb311_posix_qinfo *)rsp->Buffer;
@@ -5030,6 +5213,9 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 	int rc = 0, len;
 	int fs_infoclass_size = 0;
 
+	if (!share->path)
+		return -EIO;
+
 	rc = kern_path(share->path, LOOKUP_NO_SYMLINKS, &path);
 	if (rc) {
 		pr_err("cannot create vfs path\n");
@@ -5074,6 +5260,10 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 
 		info->Attributes |= cpu_to_le32(server_conf.share_fake_fscaps);
 
+		if (test_share_config_flag(work->tcon->share_conf,
+		    KSMBD_SHARE_FLAG_STREAMS))
+			info->Attributes |= cpu_to_le32(FILE_NAMED_STREAMS);
+
 		info->MaxPathNameComponentLength = cpu_to_le32(stfs.f_namelen);
 		len = smbConvertToUTF16((__le16 *)info->FileSystemName,
 					"NTFS", PATH_MAX, conn->local_nls, 0);
@@ -5248,7 +5438,11 @@ static int smb2_get_info_sec(struct ksmbd_work *work,
 			     struct smb2_query_info_rsp *rsp)
 {
 	struct ksmbd_file *fp;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct smb_ntsd *pntsd = (struct smb_ntsd *)rsp->Buffer, *ppntsd = NULL;
 	struct smb_fattr fattr = {{0}};
 	struct inode *inode;
@@ -5295,19 +5489,35 @@ static int smb2_get_info_sec(struct ksmbd_work *work,
 	if (!fp)
 		return -ENOENT;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = file_mnt_idmap(fp->filp);
+#else
 	user_ns = file_mnt_user_ns(fp->filp);
+#endif
 	inode = file_inode(fp->filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ksmbd_acls_fattr(&fattr, idmap, inode);
+#else
 	ksmbd_acls_fattr(&fattr, user_ns, inode);
+#endif
 
 	if (test_share_config_flag(work->tcon->share_conf,
 				   KSMBD_SHARE_FLAG_ACL_XATTR))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		ppntsd_size = ksmbd_vfs_get_sd_xattr(work->conn, idmap,
+#else
 		ppntsd_size = ksmbd_vfs_get_sd_xattr(work->conn, user_ns,
+#endif
 						     fp->filp->f_path.dentry,
 						     &ppntsd);
 
 	/* Check if sd buffer size exceeds response buffer size */
 	if (smb2_resp_buf_len(work, 8) > ppntsd_size)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = build_sec_desc(idmap, pntsd, ppntsd, ppntsd_size,
+#else
 		rc = build_sec_desc(user_ns, pntsd, ppntsd, ppntsd_size,
+#endif
 				    addition_info, &secdesclen, &fattr);
 	posix_acl_release(fattr.cf_acls);
 	posix_acl_release(fattr.cf_dacls);
@@ -5537,7 +5747,11 @@ int smb2_echo(struct ksmbd_work *work)
 
 static int smb2_rename(struct ksmbd_work *work,
 		       struct ksmbd_file *fp,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		       struct mnt_idmap *idmap,
+#else
 		       struct user_namespace *user_ns,
+#endif
 		       struct smb2_file_rename_info *file_info,
 		       struct nls_table *local_nls)
 {
@@ -5601,7 +5815,11 @@ static int smb2_rename(struct ksmbd_work *work,
 		if (rc)
 			goto out;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = ksmbd_vfs_setxattr(idmap,
+#else
 		rc = ksmbd_vfs_setxattr(user_ns,
+#endif
 					fp->filp->f_path.dentry,
 					xattr_stream_name,
 					NULL, 0, 0);
@@ -5741,7 +5959,11 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 	struct iattr attrs;
 	struct file *filp;
 	struct inode *inode;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	int rc = 0;
 
 	if (!(fp->daccess & FILE_WRITE_ATTRIBUTES_LE))
@@ -5750,7 +5972,11 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 	attrs.ia_valid = 0;
 	filp = fp->filp;
 	inode = file_inode(filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = file_mnt_idmap(filp);
+#else
 	user_ns = file_mnt_user_ns(filp);
+#endif
 
 	if (file_info->CreationTime)
 		fp->create_time = le64_to_cpu(file_info->CreationTime);
@@ -5794,7 +6020,11 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 		da.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |
 			XATTR_DOSINFO_ITIME;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = ksmbd_vfs_set_dos_attrib_xattr(idmap,
+#else
 		rc = ksmbd_vfs_set_dos_attrib_xattr(user_ns,
+#endif
 						    filp->f_path.dentry, &da);
 		if (rc)
 			ksmbd_debug(SMB,
@@ -5813,7 +6043,11 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 		inode->i_ctime = attrs.ia_ctime;
 		attrs.ia_valid &= ~ATTR_CTIME;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = notify_change(idmap, dentry, &attrs, NULL);
+#else
 		rc = notify_change(user_ns, dentry, &attrs, NULL);
+#endif
 #else
 		rc = notify_change(dentry, &attrs, NULL);
 #endif
@@ -5911,7 +6145,11 @@ static int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,
 			   struct smb2_file_rename_info *rename_info,
 			   unsigned int buf_len)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct ksmbd_file *parent_fp;
 	struct dentry *parent;
 	struct dentry *dentry = fp->filp->f_path.dentry;
@@ -5926,12 +6164,20 @@ static int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,
 			le32_to_cpu(rename_info->FileNameLength))
 		return -EINVAL;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = file_mnt_idmap(fp->filp);
+#else
 	user_ns = file_mnt_user_ns(fp->filp);
+#endif
 	if (ksmbd_stream_fd(fp))
 		goto next;
 
 	parent = dget_parent(dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ret = ksmbd_vfs_lock_parent(idmap, parent, dentry);
+#else
 	ret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);
+#endif
 	if (ret) {
 		dput(parent);
 		return ret;
@@ -5950,7 +6196,11 @@ static int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,
 		ksmbd_fd_put(work, parent_fp);
 	}
 next:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	return smb2_rename(work, fp, idmap, rename_info,
+#else
 	return smb2_rename(work, fp, user_ns, rename_info,
+#endif
 			   work->conn->local_nls);
 }
 
@@ -6775,8 +7025,7 @@ int smb2_cancel(struct ksmbd_work *work)
 	struct ksmbd_conn *conn = work->conn;
 	struct smb2_hdr *hdr = smb2_get_msg(work->request_buf);
 	struct smb2_hdr *chdr;
-	struct ksmbd_work *cancel_work = NULL;
-	int canceled = 0;
+	struct ksmbd_work *iter;
 	struct list_head *command_list;
 
 	ksmbd_debug(SMB, "smb2 cancel called on mid %llu, async flags 0x%x\n",
@@ -6786,11 +7035,11 @@ int smb2_cancel(struct ksmbd_work *work)
 		command_list = &conn->async_requests;
 
 		spin_lock(&conn->request_lock);
-		list_for_each_entry(cancel_work, command_list,
+		list_for_each_entry(iter, command_list,
 				    async_request_entry) {
-			chdr = smb2_get_msg(cancel_work->request_buf);
+			chdr = smb2_get_msg(iter->request_buf);
 
-			if (cancel_work->async_id !=
+			if (iter->async_id !=
 			    le64_to_cpu(hdr->Id.AsyncId))
 				continue;
 
@@ -6798,7 +7047,9 @@ int smb2_cancel(struct ksmbd_work *work)
 				    "smb2 with AsyncId %llu cancelled command = 0x%x\n",
 				    le64_to_cpu(hdr->Id.AsyncId),
 				    le16_to_cpu(chdr->Command));
-			canceled = 1;
+			iter->state = KSMBD_WORK_CANCELLED;
+			if (iter->cancel_fn)
+				iter->cancel_fn(iter->cancel_argv);
 			break;
 		}
 		spin_unlock(&conn->request_lock);
@@ -6806,29 +7057,23 @@ int smb2_cancel(struct ksmbd_work *work)
 		command_list = &conn->requests;
 
 		spin_lock(&conn->request_lock);
-		list_for_each_entry(cancel_work, command_list, request_entry) {
-			chdr = smb2_get_msg(cancel_work->request_buf);
+		list_for_each_entry(iter, command_list, request_entry) {
+			chdr = smb2_get_msg(iter->request_buf);
 
 			if (chdr->MessageId != hdr->MessageId ||
-			    cancel_work == work)
+			    iter == work)
 				continue;
 
 			ksmbd_debug(SMB,
 				    "smb2 with mid %llu cancelled command = 0x%x\n",
 				    le64_to_cpu(hdr->MessageId),
 				    le16_to_cpu(chdr->Command));
-			canceled = 1;
+			iter->state = KSMBD_WORK_CANCELLED;
 			break;
 		}
 		spin_unlock(&conn->request_lock);
 	}
 
-	if (canceled) {
-		cancel_work->state = KSMBD_WORK_CANCELLED;
-		if (cancel_work->cancel_fn)
-			cancel_work->cancel_fn(cancel_work->cancel_argv);
-	}
-
 	/* For SMB2_CANCEL command itself send no response*/
 	work->send_no_response = 1;
 	return 0;
@@ -7065,7 +7310,7 @@ int smb2_lock(struct ksmbd_work *work)
 
 		nolock = 1;
 		/* check locks in connection list */
-		read_lock(&conn_list_lock);
+		down_read(&conn_list_lock);
 		list_for_each_entry(conn, &conn_list, conns_list) {
 			spin_lock(&conn->llist_lock);
 			list_for_each_entry_safe(cmp_lock, tmp2, &conn->lock_list, clist) {
@@ -7082,7 +7327,7 @@ int smb2_lock(struct ksmbd_work *work)
 						list_del(&cmp_lock->flist);
 						list_del(&cmp_lock->clist);
 						spin_unlock(&conn->llist_lock);
-						read_unlock(&conn_list_lock);
+						up_read(&conn_list_lock);
 
 						locks_free_lock(cmp_lock->fl);
 						kfree(cmp_lock);
@@ -7104,7 +7349,7 @@ int smb2_lock(struct ksmbd_work *work)
 				    cmp_lock->start > smb_lock->start &&
 				    cmp_lock->start < smb_lock->end) {
 					spin_unlock(&conn->llist_lock);
-					read_unlock(&conn_list_lock);
+					up_read(&conn_list_lock);
 					pr_err("previous lock conflict with zero byte lock range\n");
 					goto out;
 				}
@@ -7113,7 +7358,7 @@ int smb2_lock(struct ksmbd_work *work)
 				    smb_lock->start > cmp_lock->start &&
 				    smb_lock->start < cmp_lock->end) {
 					spin_unlock(&conn->llist_lock);
-					read_unlock(&conn_list_lock);
+					up_read(&conn_list_lock);
 					pr_err("current lock conflict with zero byte lock range\n");
 					goto out;
 				}
@@ -7124,14 +7369,14 @@ int smb2_lock(struct ksmbd_work *work)
 				      cmp_lock->end >= smb_lock->end)) &&
 				    !cmp_lock->zero_len && !smb_lock->zero_len) {
 					spin_unlock(&conn->llist_lock);
-					read_unlock(&conn_list_lock);
+					up_read(&conn_list_lock);
 					pr_err("Not allow lock operation on exclusive lock range\n");
 					goto out;
 				}
 			}
 			spin_unlock(&conn->llist_lock);
 		}
-		read_unlock(&conn_list_lock);
+		up_read(&conn_list_lock);
 out_check_cl:
 		if (smb_lock->fl->fl_type == F_UNLCK && nolock) {
 			pr_err("Try to unlock nolocked range\n");
@@ -7193,6 +7438,10 @@ skip:
 
 				ksmbd_vfs_posix_lock_wait(flock);
 
+				spin_lock(&fp->f_lock);
+				list_del(&work->fp_entry);
+				spin_unlock(&fp->f_lock);
+
 				if (work->state != KSMBD_WORK_ACTIVE) {
 					list_del(&smb_lock->llist);
 					spin_lock(&work->conn->llist_lock);
@@ -7201,9 +7450,6 @@ skip:
 					locks_free_lock(flock);
 
 					if (work->state == KSMBD_WORK_CANCELLED) {
-						spin_lock(&fp->f_lock);
-						list_del(&work->fp_entry);
-						spin_unlock(&fp->f_lock);
 						rsp->hdr.Status =
 							STATUS_CANCELLED;
 						kfree(smb_lock);
@@ -7212,6 +7458,7 @@ skip:
 						work->send_no_response = 1;
 						goto out;
 					}
+
 					init_smb2_rsp_hdr(work);
 					smb2_set_err_rsp(work);
 					rsp->hdr.Status =
@@ -7224,10 +7471,7 @@ skip:
 				spin_lock(&work->conn->llist_lock);
 				list_del(&smb_lock->clist);
 				spin_unlock(&work->conn->llist_lock);
-
-				spin_lock(&fp->f_lock);
-				list_del(&work->fp_entry);
-				spin_unlock(&fp->f_lock);
+				release_async_work(work);
 				goto retry;
 			} else if (!rc) {
 				spin_lock(&work->conn->llist_lock);
@@ -7597,13 +7841,16 @@ static int fsctl_query_allocated_ranges(struct ksmbd_work *work, u64 id,
 	if (in_count == 0)
 		return -EINVAL;
 
+	start = le64_to_cpu(qar_req->file_offset);
+	length = le64_to_cpu(qar_req->length);
+
+	if (start < 0 || length < 0)
+		return -EINVAL;
+
 	fp = ksmbd_lookup_fd_fast(work, id);
 	if (!fp)
 		return -ENOENT;
 
-	start = le64_to_cpu(qar_req->file_offset);
-	length = le64_to_cpu(qar_req->length);
-
 	ret = ksmbd_vfs_fqar_lseek(fp, start, length,
 				   qar_rsp, in_count, out_count);
 	if (ret && ret != -E2BIG)
@@ -7662,14 +7909,22 @@ static inline int fsctl_set_sparse(struct ksmbd_work *work, u64 id,
 				   struct file_sparse *sparse)
 {
 	struct ksmbd_file *fp;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	int ret = 0;
 	__le32 old_fattr;
 
 	fp = ksmbd_lookup_fd_fast(work, id);
 	if (!fp)
 		return -ENOENT;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = file_mnt_idmap(fp->filp);
+#else
 	user_ns = file_mnt_user_ns(fp->filp);
+#endif
 
 	old_fattr = fp->f_ci->m_fattr;
 	if (sparse->SetSparse)
@@ -7682,13 +7937,21 @@ static inline int fsctl_set_sparse(struct ksmbd_work *work, u64 id,
 				   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
 		struct xattr_dos_attrib da;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		ret = ksmbd_vfs_get_dos_attrib_xattr(idmap,
+#else
 		ret = ksmbd_vfs_get_dos_attrib_xattr(user_ns,
+#endif
 						     fp->filp->f_path.dentry, &da);
 		if (ret <= 0)
 			goto out;
 
 		da.attr = le32_to_cpu(fp->f_ci->m_fattr);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		ret = ksmbd_vfs_set_dos_attrib_xattr(idmap,
+#else
 		ret = ksmbd_vfs_set_dos_attrib_xattr(user_ns,
+#endif
 						     fp->filp->f_path.dentry, &da);
 		if (ret)
 			fp->f_ci->m_fattr = old_fattr;
@@ -7904,7 +8167,7 @@ int smb2_ioctl(struct ksmbd_work *work)
 
 		off = le64_to_cpu(zero_data->FileOffset);
 		bfz = le64_to_cpu(zero_data->BeyondFinalZero);
-		if (off > bfz) {
+		if (off < 0 || bfz < 0 || off > bfz) {
 			ret = -EINVAL;
 			goto out;
 		}
@@ -8081,8 +8344,8 @@ static void smb20_oplock_break_ack(struct ksmbd_work *work)
 	char req_oplevel = 0, rsp_oplevel = 0;
 	unsigned int oplock_change_type;
 
-	volatile_id = le64_to_cpu(req->VolatileFid);
-	persistent_id = le64_to_cpu(req->PersistentFid);
+	volatile_id = req->VolatileFid;
+	persistent_id = req->PersistentFid;
 	req_oplevel = req->OplockLevel;
 	ksmbd_debug(OPLOCK, "v_id %llu, p_id %llu request oplock level %d\n",
 		    volatile_id, persistent_id, req_oplevel);
@@ -8177,8 +8440,8 @@ static void smb20_oplock_break_ack(struct ksmbd_work *work)
 	rsp->OplockLevel = rsp_oplevel;
 	rsp->Reserved = 0;
 	rsp->Reserved2 = 0;
-	rsp->VolatileFid = cpu_to_le64(volatile_id);
-	rsp->PersistentFid = cpu_to_le64(persistent_id);
+	rsp->VolatileFid = volatile_id;
+	rsp->PersistentFid = persistent_id;
 	inc_rfc1001_len(work->response_buf, 24);
 	return;
 
@@ -8541,14 +8804,11 @@ int smb3_check_sign_req(struct ksmbd_work *work)
 	if (le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {
 		signing_key = work->sess->smb3signingkey;
 	} else {
-		read_lock(&work->sess->chann_lock);
 		chann = lookup_chann_list(work->sess, conn);
 		if (!chann) {
-			read_unlock(&work->sess->chann_lock);
 			return 0;
 		}
 		signing_key = chann->smb3signingkey;
-		read_unlock(&work->sess->chann_lock);
 	}
 
 	if (!signing_key) {
@@ -8608,14 +8868,11 @@ void smb3_set_sign_rsp(struct ksmbd_work *work)
 	    le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {
 		signing_key = work->sess->smb3signingkey;
 	} else {
-		read_lock(&work->sess->chann_lock);
 		chann = lookup_chann_list(work->sess, work->conn);
 		if (!chann) {
-			read_unlock(&work->sess->chann_lock);
 			return;
 		}
 		signing_key = chann->smb3signingkey;
-		read_unlock(&work->sess->chann_lock);
 	}
 
 	if (!signing_key)
@@ -8795,6 +9052,7 @@ int smb3_decrypt_req(struct ksmbd_work *work)
 bool smb3_11_final_sess_setup_resp(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
+	struct ksmbd_session *sess = work->sess;
 	struct smb2_hdr *rsp = smb2_get_msg(work->response_buf);
 
 	if (conn->dialect < SMB30_PROT_ID)
@@ -8804,6 +9062,7 @@ bool smb3_11_final_sess_setup_resp(struct ksmbd_work *work)
 		rsp = ksmbd_resp_buf_next(work);
 
 	if (le16_to_cpu(rsp->Command) == SMB2_SESSION_SETUP_HE &&
+	    sess->user && !user_guest(sess->user) &&
 	    rsp->Status == STATUS_SUCCESS)
 		return true;
 	return false;
diff --git a/smb2pdu.h b/smb2pdu.h
index ee649d1..1719b0c 100644
--- a/smb2pdu.h
+++ b/smb2pdu.h
@@ -113,8 +113,9 @@
 #define SMB21_DEFAULT_IOSIZE	(1024 * 1024)
 #define SMB3_DEFAULT_IOSIZE	(4 * 1024 * 1024)
 #define SMB3_DEFAULT_TRANS_SIZE	(1024 * 1024)
-#define SMB3_MIN_IOSIZE	(64 * 1024)
-#define SMB3_MAX_IOSIZE	(8 * 1024 * 1024)
+#define SMB3_MIN_IOSIZE		(64 * 1024)
+#define SMB3_MAX_IOSIZE		(8 * 1024 * 1024)
+#define SMB3_MAX_MSGSIZE	(4 * 4096)
 
 /*
  * SMB2 Header Definition
@@ -365,6 +366,8 @@ struct smb2_negotiate_rsp {
 #define SMB2_SESSION_IN_PROGRESS	BIT(0)
 #define SMB2_SESSION_VALID		BIT(1)
 
+#define SMB2_SESSION_TIMEOUT		(10 * HZ)
+
 /* Flags */
 #define SMB2_SESSION_REQ_FLAG_BINDING		0x01
 #define SMB2_SESSION_REQ_FLAG_ENCRYPT_DATA	0x04
@@ -1663,6 +1666,7 @@ int find_matching_smb2_dialect(int start_index, __le16 *cli_dialects,
 struct file_lock *smb_flock_init(struct file *f);
 int setup_async_work(struct ksmbd_work *work, void (*fn)(void **),
 		     void **arg);
+void release_async_work(struct ksmbd_work *work);
 void smb2_send_interim_resp(struct ksmbd_work *work, __le32 status);
 struct channel *lookup_chann_list(struct ksmbd_session *sess,
 				  struct ksmbd_conn *conn);
diff --git a/smb_common.c b/smb_common.c
index c047d5e..c6bd9f2 100644
--- a/smb_common.c
+++ b/smb_common.c
@@ -7,9 +7,7 @@
 #include <linux/user_namespace.h>
 
 #include "smb_common.h"
-#ifdef CONFIG_SMB_INSECURE_SERVER
 #include "smb1pdu.h"
-#endif
 #include "server.h"
 #include "misc.h"
 #include "smbstatus.h"
@@ -321,36 +319,121 @@ err_out:
 	return BAD_PROT_ID;
 }
 
-#define SMB_COM_NEGOTIATE	0x72
-int ksmbd_init_smb_server(struct ksmbd_work *work)
+#ifndef CONFIG_SMB_INSECURE_SERVER
+#define SMB_COM_NEGOTIATE_EX	0x0
+
+/**
+ * get_smb1_cmd_val() - get smb command value from smb header
+ * @work:	smb work containing smb header
+ *
+ * Return:      smb command value
+ */
+static u16 get_smb1_cmd_val(struct ksmbd_work *work)
+{
+	return SMB_COM_NEGOTIATE_EX;
+}
+
+/**
+ * init_smb1_rsp_hdr() - initialize smb negotiate response header
+ * @work:	smb work containing smb request
+ *
+ * Return:      0 on success, otherwise -EINVAL
+ */
+static int init_smb1_rsp_hdr(struct ksmbd_work *work)
+{
+	struct smb_hdr *rsp_hdr = (struct smb_hdr *)work->response_buf;
+	struct smb_hdr *rcv_hdr = (struct smb_hdr *)work->request_buf;
+
+	/*
+	 * Remove 4 byte direct TCP header.
+	 */
+	*(__be32 *)work->response_buf =
+		cpu_to_be32(sizeof(struct smb_hdr) - 4);
+
+	rsp_hdr->Command = SMB_COM_NEGOTIATE;
+	*(__le32 *)rsp_hdr->Protocol = SMB1_PROTO_NUMBER;
+	rsp_hdr->Flags = SMBFLG_RESPONSE;
+	rsp_hdr->Flags2 = SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS |
+		SMBFLG2_EXT_SEC | SMBFLG2_IS_LONG_NAME;
+	rsp_hdr->Pid = rcv_hdr->Pid;
+	rsp_hdr->Mid = rcv_hdr->Mid;
+	return 0;
+}
+
+/**
+ * smb1_check_user_session() - check for valid session for a user
+ * @work:	smb work containing smb request buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+static int smb1_check_user_session(struct ksmbd_work *work)
+{
+	unsigned int cmd = work->conn->ops->get_cmd_val(work);
+
+	if (cmd == SMB_COM_NEGOTIATE_EX)
+		return 0;
+
+	return -EINVAL;
+}
+
+/**
+ * smb1_allocate_rsp_buf() - allocate response buffer for a command
+ * @work:	smb work containing smb request
+ *
+ * Return:      0 on success, otherwise -ENOMEM
+ */
+static int smb1_allocate_rsp_buf(struct ksmbd_work *work)
+{
+	work->response_buf = kzalloc(MAX_CIFS_SMALL_BUFFER_SIZE,
+			GFP_KERNEL);
+	work->response_sz = MAX_CIFS_SMALL_BUFFER_SIZE;
+
+	if (!work->response_buf) {
+		pr_err("Failed to allocate %u bytes buffer\n",
+				MAX_CIFS_SMALL_BUFFER_SIZE);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static struct smb_version_ops smb1_server_ops = {
+	.get_cmd_val = get_smb1_cmd_val,
+	.init_rsp_hdr = init_smb1_rsp_hdr,
+	.allocate_rsp_buf = smb1_allocate_rsp_buf,
+	.check_user_session = smb1_check_user_session,
+};
+
+static int smb1_negotiate(struct ksmbd_work *work)
+{
+	return ksmbd_smb_negotiate_common(work, SMB_COM_NEGOTIATE);
+}
+
+static struct smb_version_cmds smb1_server_cmds[1] = {
+	[SMB_COM_NEGOTIATE_EX]	= { .proc = smb1_negotiate, },
+};
+
+static void init_smb1_server(struct ksmbd_conn *conn)
+{
+	conn->ops = &smb1_server_ops;
+	conn->cmds = smb1_server_cmds;
+	conn->max_cmds = ARRAY_SIZE(smb1_server_cmds);
+}
+#endif
+
+void ksmbd_init_smb_server(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
-#ifdef CONFIG_SMB_INSECURE_SERVER
-	void *buf = work->request_buf;
 	__le32 proto;
-#endif
 
 	if (conn->need_neg == false)
-		return 0;
+		return;
 
-#ifdef CONFIG_SMB_INSECURE_SERVER
-	proto = *(__le32 *)((struct smb_hdr *)buf)->Protocol;
+	proto = *(__le32 *)((struct smb_hdr *)work->request_buf)->Protocol;
 	if (proto == SMB1_PROTO_NUMBER)
 		init_smb1_server(conn);
 	else
 		init_smb3_11_server(conn);
-#else
-	init_smb3_11_server(conn);
-#endif
-
-	if (conn->ops->get_cmd_val(work) != SMB_COM_NEGOTIATE)
-		conn->need_neg = false;
-	return 0;
-}
-
-bool ksmbd_pdu_size_has_room(unsigned int pdu)
-{
-	return (pdu >= KSMBD_MIN_SUPPORTED_HEADER_SIZE - 4);
 }
 
 int ksmbd_populate_dot_dotdot_entries(struct ksmbd_work *work, int info_level,
@@ -363,7 +446,11 @@ int ksmbd_populate_dot_dotdot_entries(struct ksmbd_work *work, int info_level,
 {
 	int i, rc = 0;
 	struct ksmbd_conn *conn = work->conn;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(dir->filp);
+#else
 	struct user_namespace *user_ns = file_mnt_user_ns(dir->filp);
+#endif
 
 	for (i = 0; i < 2; i++) {
 		struct kstat kstat;
@@ -389,7 +476,11 @@ int ksmbd_populate_dot_dotdot_entries(struct ksmbd_work *work, int info_level,
 
 			ksmbd_kstat.kstat = &kstat;
 			ksmbd_vfs_fill_dentry_attrs(work,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+						    idmap,
+#else
 						    user_ns,
+#endif
 						    dentry,
 						    &ksmbd_kstat);
 			rc = fn(conn, info_level, d_info, &ksmbd_kstat);
@@ -499,9 +590,16 @@ static int smb_handle_negotiate(struct ksmbd_work *work)
 {
 	struct smb_negotiate_rsp *neg_rsp = work->response_buf;
 
-	ksmbd_debug(SMB, "Unsupported SMB protocol\n");
-	neg_rsp->hdr.Status.CifsError = STATUS_INVALID_LOGON_TYPE;
-	return -EINVAL;
+	ksmbd_debug(SMB, "Unsupported SMB1 protocol\n");
+
+	/* Add 2 byte bcc and 2 byte DialectIndex. */
+	inc_rfc1001_len(work->response_buf, 4);
+	neg_rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+
+	neg_rsp->hdr.WordCount = 1;
+	neg_rsp->DialectIndex = cpu_to_le16(work->conn->dialect);
+	neg_rsp->ByteCount = 0;
+	return 0;
 }
 #endif
 
@@ -514,24 +612,13 @@ int ksmbd_smb_negotiate_common(struct ksmbd_work *work, unsigned int command)
 		ksmbd_negotiate_smb_dialect(work->request_buf);
 	ksmbd_debug(SMB, "conn->dialect 0x%x\n", conn->dialect);
 
-	if (command == SMB2_NEGOTIATE_HE) {
-		struct smb2_hdr *smb2_hdr = smb2_get_msg(work->request_buf);
-
-		if (smb2_hdr->ProtocolId != SMB2_PROTO_NUMBER) {
-			ksmbd_debug(SMB, "Downgrade to SMB1 negotiation\n");
-			command = SMB_COM_NEGOTIATE;
-		}
-	}
-
 	if (command == SMB2_NEGOTIATE_HE) {
 		ret = smb2_handle_negotiate(work);
-		init_smb2_neg_rsp(work);
 		return ret;
 	}
 
 	if (command == SMB_COM_NEGOTIATE) {
 		if (__smb2_negotiate(conn)) {
-			conn->need_neg = true;
 			init_smb3_11_server(conn);
 			init_smb2_neg_rsp(work);
 			ksmbd_debug(SMB, "Upgrade to SMB2 negotiation\n");
@@ -681,7 +768,7 @@ int ksmbd_override_fsids(struct ksmbd_work *work)
 	if (share->force_gid != KSMBD_SHARE_INVALID_GID)
 		gid = share->force_gid;
 
-	cred = prepare_kernel_cred(NULL);
+	cred = prepare_kernel_cred(&init_task);
 	if (!cred)
 		return -ENOMEM;
 
diff --git a/smb_common.h b/smb_common.h
index fe5dfc8..81e6702 100644
--- a/smb_common.h
+++ b/smb_common.h
@@ -246,31 +246,10 @@ struct smb_negotiate_req {
 	unsigned char DialectsArray[1];
 } __packed;
 
-struct smb_negotiate_rsp {
+struct smb_negotiate_unsupported_rsp {
 	struct smb_hdr hdr;     /* wct = 17 */
 	__le16 DialectIndex; /* 0xFFFF = no dialect acceptable */
-	__u8 SecurityMode;
-	__le16 MaxMpxCount;
-	__le16 MaxNumberVcs;
-	__le32 MaxBufferSize;
-	__le32 MaxRawSize;
-	__le32 SessionKey;
-	__le32 Capabilities;    /* see below */
-	__le32 SystemTimeLow;
-	__le32 SystemTimeHigh;
-	__le16 ServerTimeZone;
-	__u8 EncryptionKeyLength;
 	__le16 ByteCount;
-	union {
-		unsigned char EncryptionKey[8]; /* cap extended security off */
-		/* followed by Domain name - if extended security is off */
-		/* followed by 16 bytes of server GUID */
-		/* then security blob if cap_extended_security negotiated */
-		struct {
-			unsigned char GUID[SMB1_CLIENT_GUID_SIZE];
-			unsigned char SecurityBlob[1];
-		} __packed extended_response;
-	} __packed u;
 } __packed;
 
 struct filesystem_attribute_info {
@@ -491,7 +470,7 @@ bool ksmbd_smb_request(struct ksmbd_conn *conn);
 
 int ksmbd_lookup_dialect_by_id(__le16 *cli_dialects, __le16 dialects_count);
 
-int ksmbd_init_smb_server(struct ksmbd_work *work);
+void ksmbd_init_smb_server(struct ksmbd_work *work);
 
 bool ksmbd_pdu_size_has_room(unsigned int pdu);
 
diff --git a/smbacl.c b/smbacl.c
index 7a18d1f..dce69bb 100644
--- a/smbacl.c
+++ b/smbacl.c
@@ -257,7 +257,11 @@ void id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid)
 	ssid->num_subauth++;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static int sid_to_id(struct mnt_idmap *idmap,
+#else
 static int sid_to_id(struct user_namespace *user_ns,
+#endif
 		     struct smb_sid *psid, uint sidtype,
 		     struct smb_fattr *fattr)
 {
@@ -285,7 +289,11 @@ static int sid_to_id(struct user_namespace *user_ns,
     (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 52) && LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 		uid = KUIDT_INIT(id);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		uid = from_vfsuid(idmap, &init_user_ns, VFSUIDT_INIT(uid));
+#else
 		uid = from_vfsuid(user_ns, &init_user_ns, VFSUIDT_INIT(uid));
+#endif
 #else
 		uid = mapped_kuid_user(user_ns, &init_user_ns, KUIDT_INIT(id));
 #endif
@@ -314,7 +322,11 @@ static int sid_to_id(struct user_namespace *user_ns,
     (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 52) && LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 		gid = KGIDT_INIT(id);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		gid = from_vfsgid(idmap, &init_user_ns, VFSGIDT_INIT(gid));
+#else
 		gid = from_vfsgid(user_ns, &init_user_ns, VFSGIDT_INIT(gid));
+#endif
 #else
 		gid = mapped_kgid_user(user_ns, &init_user_ns, KGIDT_INIT(id));
 #endif
@@ -404,7 +416,11 @@ void free_acl_state(struct posix_acl_state *state)
 	kfree(state->groups);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static void parse_dacl(struct mnt_idmap *idmap,
+#else
 static void parse_dacl(struct user_namespace *user_ns,
+#endif
 		       struct smb_acl *pdacl, char *end_of_acl,
 		       struct smb_sid *pownersid, struct smb_sid *pgrpsid,
 		       struct smb_fattr *fattr)
@@ -531,7 +547,11 @@ static void parse_dacl(struct user_namespace *user_ns,
 			acl_mode = access_flags_to_mode(fattr, ppace[i]->access_req,
 							ppace[i]->type);
 			temp_fattr.cf_uid = INVALID_UID;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			ret = sid_to_id(idmap, &ppace[i]->sid, SIDOWNER, &temp_fattr);
+#else
 			ret = sid_to_id(user_ns, &ppace[i]->sid, SIDOWNER, &temp_fattr);
+#endif
 			if (ret || uid_eq(temp_fattr.cf_uid, INVALID_UID)) {
 				pr_err("%s: Error %d mapping Owner SID to uid\n",
 				       __func__, ret);
@@ -617,7 +637,11 @@ static void parse_dacl(struct user_namespace *user_ns,
 	free_acl_state(&default_acl_state);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static void set_posix_acl_entries_dacl(struct mnt_idmap *idmap,
+#else
 static void set_posix_acl_entries_dacl(struct user_namespace *user_ns,
+#endif
 				       struct smb_ace *pndace,
 				       struct smb_fattr *fattr, u32 *num_aces,
 				       u16 *size, u32 nt_aces_num)
@@ -642,14 +666,22 @@ static void set_posix_acl_entries_dacl(struct user_namespace *user_ns,
 			uid_t uid;
 			unsigned int sid_type = SIDOWNER;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			uid = posix_acl_uid_translate(idmap, pace);
+#else
 			uid = posix_acl_uid_translate(user_ns, pace);
+#endif
 			if (!uid)
 				sid_type = SIDUNIX_USER;
 			id_to_sid(uid, sid_type, sid);
 		} else if (pace->e_tag == ACL_GROUP) {
 			gid_t gid;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			gid = posix_acl_gid_translate(idmap, pace);
+#else
 			gid = posix_acl_gid_translate(user_ns, pace);
+#endif
 			id_to_sid(gid, SIDUNIX_GROUP, sid);
 		} else if (pace->e_tag == ACL_OTHER && !nt_aces_num) {
 			smb_copy_sid(sid, &sid_everyone);
@@ -708,12 +740,20 @@ posix_default_acl:
 		if (pace->e_tag == ACL_USER) {
 			uid_t uid;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			uid = posix_acl_uid_translate(idmap, pace);
+#else
 			uid = posix_acl_uid_translate(user_ns, pace);
+#endif
 			id_to_sid(uid, SIDCREATOR_OWNER, sid);
 		} else if (pace->e_tag == ACL_GROUP) {
 			gid_t gid;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			gid = posix_acl_gid_translate(idmap, pace);
+#else
 			gid = posix_acl_gid_translate(user_ns, pace);
+#endif
 			id_to_sid(gid, SIDCREATOR_GROUP, sid);
 		} else {
 			kfree(sid);
@@ -731,7 +771,11 @@ posix_default_acl:
 	}
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static void set_ntacl_dacl(struct mnt_idmap *idmap,
+#else
 static void set_ntacl_dacl(struct user_namespace *user_ns,
+#endif
 			   struct smb_acl *pndacl,
 			   struct smb_acl *nt_dacl,
 			   unsigned int aces_size,
@@ -765,13 +809,21 @@ static void set_ntacl_dacl(struct user_namespace *user_ns,
 		}
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	set_posix_acl_entries_dacl(idmap, pndace, fattr,
+#else
 	set_posix_acl_entries_dacl(user_ns, pndace, fattr,
+#endif
 				   &num_aces, &size, nt_num_aces);
 	pndacl->num_aces = cpu_to_le32(num_aces);
 	pndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static void set_mode_dacl(struct mnt_idmap *idmap,
+#else
 static void set_mode_dacl(struct user_namespace *user_ns,
+#endif
 			  struct smb_acl *pndacl, struct smb_fattr *fattr)
 {
 	struct smb_ace *pace, *pndace;
@@ -783,7 +835,11 @@ static void set_mode_dacl(struct user_namespace *user_ns,
 	pace = pndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));
 
 	if (fattr->cf_acls) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		set_posix_acl_entries_dacl(idmap, pndace, fattr,
+#else
 		set_posix_acl_entries_dacl(user_ns, pndace, fattr,
+#endif
 					   &num_aces, &size, num_aces);
 		goto out;
 	}
@@ -850,7 +906,11 @@ static int parse_sid(struct smb_sid *psid, char *end_of_acl)
 }
 
 /* Convert CIFS ACL to POSIX form */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int parse_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,
+#else
 int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
+#endif
 		   int acl_len, struct smb_fattr *fattr)
 {
 	int rc = 0;
@@ -893,7 +953,11 @@ int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
 			return rc;
 		}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = sid_to_id(idmap, owner_sid_ptr, SIDOWNER, fattr);
+#else
 		rc = sid_to_id(user_ns, owner_sid_ptr, SIDOWNER, fattr);
+#endif
 		if (rc) {
 			pr_err("%s: Error %d mapping Owner SID to uid\n",
 			       __func__, rc);
@@ -908,7 +972,11 @@ int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
 			       __func__, rc);
 			return rc;
 		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = sid_to_id(idmap, group_sid_ptr, SIDUNIX_GROUP, fattr);
+#else
 		rc = sid_to_id(user_ns, group_sid_ptr, SIDUNIX_GROUP, fattr);
+#endif
 		if (rc) {
 			pr_err("%s: Error %d mapping Group SID to gid\n",
 			       __func__, rc);
@@ -923,7 +991,11 @@ int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
 		pntsd->type |= cpu_to_le16(DACL_PROTECTED);
 
 	if (dacloffset) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		parse_dacl(idmap, dacl_ptr, end_of_acl,
+#else
 		parse_dacl(user_ns, dacl_ptr, end_of_acl,
+#endif
 			   owner_sid_ptr, group_sid_ptr, fattr);
 	}
 
@@ -931,7 +1003,11 @@ int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
 }
 
 /* Convert permission bits from mode to equivalent CIFS ACL */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int build_sec_desc(struct mnt_idmap *idmap,
+#else
 int build_sec_desc(struct user_namespace *user_ns,
+#endif
 		   struct smb_ntsd *pntsd, struct smb_ntsd *ppntsd,
 		   int ppntsd_size, int addition_info, __u32 *secdesclen,
 		   struct smb_fattr *fattr)
@@ -992,7 +1068,11 @@ int build_sec_desc(struct user_namespace *user_ns,
 		dacl_ptr->num_aces = 0;
 
 		if (!ppntsd) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			set_mode_dacl(idmap, dacl_ptr, fattr);
+#else
 			set_mode_dacl(user_ns, dacl_ptr, fattr);
+#endif
 		} else {
 			struct smb_acl *ppdacl_ptr;
 			unsigned int dacl_offset = le32_to_cpu(ppntsd->dacloffset);
@@ -1008,7 +1088,11 @@ int build_sec_desc(struct user_namespace *user_ns,
 			    ppdacl_size < sizeof(struct smb_acl))
 				goto out;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			set_ntacl_dacl(idmap, dacl_ptr, ppdacl_ptr,
+#else
 			set_ntacl_dacl(user_ns, dacl_ptr, ppdacl_ptr,
+#endif
 				       ntacl_size - sizeof(struct smb_acl),
 				       nowner_sid_ptr, ngroup_sid_ptr,
 				       fattr);
@@ -1044,13 +1128,21 @@ int smb_inherit_dacl(struct ksmbd_conn *conn,
 	struct smb_ntsd *parent_pntsd = NULL;
 	struct smb_sid owner_sid, group_sid;
 	struct dentry *parent = path->dentry->d_parent;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	int inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;
 	int rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;
 	char *aces_base;
 	bool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	pntsd_size = ksmbd_vfs_get_sd_xattr(conn, idmap,
+#else
 	pntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,
+#endif
 					    parent, &parent_pntsd);
 	if (pntsd_size <= 0)
 		return -ENOENT;
@@ -1204,7 +1296,11 @@ pass:
 			pntsd_size += sizeof(struct smb_acl) + nt_size;
 		}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		ksmbd_vfs_set_sd_xattr(conn, idmap,
+#else
 		ksmbd_vfs_set_sd_xattr(conn, user_ns,
+#endif
 				       path->dentry, pntsd, pntsd_size);
 		kfree(pntsd);
 	}
@@ -1232,7 +1328,11 @@ bool smb_inherit_flags(int flags, bool is_dir)
 int smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,
 			__le32 *pdaccess, int uid)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	struct smb_ntsd *pntsd = NULL;
 	struct smb_acl *pdacl;
 	struct posix_acl *posix_acls;
@@ -1248,7 +1348,11 @@ int smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,
 	unsigned short ace_size;
 
 	ksmbd_debug(SMB, "check permission using windows acl\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	pntsd_size = ksmbd_vfs_get_sd_xattr(conn, idmap,
+#else
 	pntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,
+#endif
 					    path->dentry, &pntsd);
 	if (pntsd_size <= 0 || !pntsd)
 		goto err_out;
@@ -1331,16 +1435,28 @@ int smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,
 	}
 
 	if (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+		posix_acls = get_inode_acl(d_inode(path->dentry), ACL_TYPE_ACCESS);
+#else
 		posix_acls = get_acl(d_inode(path->dentry), ACL_TYPE_ACCESS);
+#endif
 		if (posix_acls && !found) {
 			unsigned int id = -1;
 
 			pa_entry = posix_acls->a_entries;
 			for (i = 0; i < posix_acls->a_count; i++, pa_entry++) {
 				if (pa_entry->e_tag == ACL_USER)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					id = posix_acl_uid_translate(idmap, pa_entry);
+#else
 					id = posix_acl_uid_translate(user_ns, pa_entry);
+#endif
 				else if (pa_entry->e_tag == ACL_GROUP)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					id = posix_acl_gid_translate(idmap, pa_entry);
+#else
 					id = posix_acl_gid_translate(user_ns, pa_entry);
+#endif
 				else
 					continue;
 
@@ -1402,14 +1518,22 @@ int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 	int rc;
 	struct smb_fattr fattr = {{0}};
 	struct inode *inode = d_inode(path->dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	struct iattr newattrs;
 
 	fattr.cf_uid = INVALID_UID;
 	fattr.cf_gid = INVALID_GID;
 	fattr.cf_mode = inode->i_mode;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = parse_sec_desc(idmap, pntsd, ntsd_len, &fattr);
+#else
 	rc = parse_sec_desc(user_ns, pntsd, ntsd_len, &fattr);
+#endif
 	if (rc)
 		goto out;
 
@@ -1426,11 +1550,23 @@ int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 	newattrs.ia_valid |= ATTR_MODE;
 	newattrs.ia_mode = (inode->i_mode & ~0777) | (fattr.cf_mode & 0777);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ksmbd_vfs_remove_acl_xattrs(idmap, path->dentry);
+#else
 	ksmbd_vfs_remove_acl_xattrs(user_ns, path->dentry);
+#endif
 	/* Update posix acls */
 	if (IS_ENABLED(CONFIG_FS_POSIX_ACL) && fattr.cf_dacls) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = set_posix_acl(idmap, path->dentry,
+#else
+		rc = set_posix_acl(user_ns, path->dentry,
+#endif
+#else
 		rc = set_posix_acl(user_ns, inode,
+#endif
 				   ACL_TYPE_ACCESS,
 				   fattr.cf_acls);
 #else
@@ -1442,7 +1578,15 @@ int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 				    rc);
 		if (S_ISDIR(inode->i_mode) && fattr.cf_dacls) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			rc = set_posix_acl(idmap, path->dentry,
+#else
+			rc = set_posix_acl(user_ns, path->dentry,
+#endif
+#else
 			rc = set_posix_acl(user_ns, inode,
+#endif
 					   ACL_TYPE_DEFAULT, fattr.cf_dacls);
 #else
 			rc = set_posix_acl(inode, ACL_TYPE_DEFAULT,
@@ -1457,7 +1601,11 @@ int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 
 	inode_lock(inode);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = notify_change(idmap, path->dentry, &newattrs, NULL);
+#else
 	rc = notify_change(user_ns, path->dentry, &newattrs, NULL);
+#endif
 #else
 	rc = notify_change(path->dentry, &newattrs, NULL);
 #endif
@@ -1471,8 +1619,13 @@ int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 
 	if (test_share_config_flag(tcon->share_conf, KSMBD_SHARE_FLAG_ACL_XATTR)) {
 		/* Update WinACL in xattr */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		ksmbd_vfs_remove_sd_xattrs(idmap, path->dentry);
+		ksmbd_vfs_set_sd_xattr(conn, idmap,
+#else
 		ksmbd_vfs_remove_sd_xattrs(user_ns, path->dentry);
 		ksmbd_vfs_set_sd_xattr(conn, user_ns,
+#endif
 				       path->dentry, pntsd, ntsd_len);
 	}
 
diff --git a/smbacl.h b/smbacl.h
index d153aab..4e00066 100644
--- a/smbacl.h
+++ b/smbacl.h
@@ -193,9 +193,17 @@ struct posix_acl_state {
 	struct posix_ace_state_array *groups;
 };
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int parse_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,
+#else
 int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
+#endif
 		   int acl_len, struct smb_fattr *fattr);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int build_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,
+#else
 int build_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
+#endif
 		   struct smb_ntsd *ppntsd, int ppntsd_size, int addition_info,
 		   __u32 *secdesclen, struct smb_fattr *fattr);
 int init_acl_state(struct posix_acl_state *state, int cnt);
@@ -214,7 +222,11 @@ int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 void id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid);
 void ksmbd_init_domain(u32 *sub_auth);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static inline uid_t posix_acl_uid_translate(struct mnt_idmap *idmap,
+#else
 static inline uid_t posix_acl_uid_translate(struct user_namespace *mnt_userns,
+#endif
 					    struct posix_acl_entry *pace)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
@@ -228,7 +240,11 @@ static inline uid_t posix_acl_uid_translate(struct user_namespace *mnt_userns,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0) || \
     (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 52) && LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsuid = make_vfsuid(idmap, &init_user_ns, pace->e_uid);
+#else
 	vfsuid = make_vfsuid(mnt_userns, &init_user_ns, pace->e_uid);
+#endif
 #else
 	kuid = mapped_kuid_fs(mnt_userns, &init_user_ns, pace->e_uid);
 #endif
@@ -247,7 +263,11 @@ static inline uid_t posix_acl_uid_translate(struct user_namespace *mnt_userns,
 #endif
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static inline gid_t posix_acl_gid_translate(struct mnt_idmap *idmap,
+#else
 static inline gid_t posix_acl_gid_translate(struct user_namespace *mnt_userns,
+#endif
 					    struct posix_acl_entry *pace)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
@@ -261,7 +281,11 @@ static inline gid_t posix_acl_gid_translate(struct user_namespace *mnt_userns,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0) || \
     (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 52) && LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsgid = make_vfsgid(idmap, &init_user_ns, pace->e_gid);
+#else
 	vfsgid = make_vfsgid(mnt_userns, &init_user_ns, pace->e_gid);
+#endif
 #else
 	kgid = mapped_kgid_fs(mnt_userns, &init_user_ns, pace->e_gid);
 #endif
diff --git a/transport_ipc.c b/transport_ipc.c
index 7995d1a..d5a871d 100644
--- a/transport_ipc.c
+++ b/transport_ipc.c
@@ -310,6 +310,9 @@ static int ipc_server_config_on_startup(struct ksmbd_startup_request *req)
 	if (req->smbd_max_io_size)
 		init_smbd_max_io_size(req->smbd_max_io_size);
 
+	if (req->max_connections)
+		server_conf.max_connections = req->max_connections;
+
 	ret = ksmbd_set_netbios_name(req->netbios_name);
 	ret |= ksmbd_set_server_string(req->server_string);
 	ret |= ksmbd_set_work_group(req->work_group);
diff --git a/transport_rdma.c b/transport_rdma.c
index 7c6758c..7f2a642 100644
--- a/transport_rdma.c
+++ b/transport_rdma.c
@@ -670,7 +670,7 @@ static int smb_direct_post_recv(struct smb_direct_transport *t,
 }
 
 static int smb_direct_read(struct ksmbd_transport *t, char *buf,
-			   unsigned int size)
+			   unsigned int size, int unused)
 {
 	struct smb_direct_recvmsg *recvmsg;
 	struct smb_direct_data_transfer *data_transfer;
diff --git a/transport_tcp.c b/transport_tcp.c
index ad94bfe..b5db6b4 100644
--- a/transport_tcp.c
+++ b/transport_tcp.c
@@ -15,6 +15,8 @@
 #define IFACE_STATE_DOWN		BIT(0)
 #define IFACE_STATE_CONFIGURED		BIT(1)
 
+static atomic_t active_num_conn;
+
 struct interface {
 	struct task_struct	*ksmbd_kthread;
 	struct socket		*ksmbd_socket;
@@ -213,8 +215,10 @@ static int ksmbd_tcp_new_connection(struct socket *client_sk)
 	struct tcp_transport *t;
 
 	t = alloc_transport(client_sk);
-	if (!t)
+	if (!t) {
+		sock_release(client_sk);
 		return -ENOMEM;
+	}
 
 	csin = KSMBD_TCP_PEER_SOCKADDR(KSMBD_TRANS(t)->conn);
 
@@ -267,6 +271,15 @@ static int ksmbd_kthread_fn(void *p)
 			continue;
 		}
 
+		if (server_conf.max_connections &&
+		    atomic_inc_return(&active_num_conn) >= server_conf.max_connections) {
+			pr_info_ratelimited("Limit the maximum number of connections(%u)\n",
+					    atomic_read(&active_num_conn));
+			atomic_dec(&active_num_conn);
+			sock_release(client_sk);
+			continue;
+		}
+
 		ksmbd_debug(CONN, "connect success: accepted new connection\n");
 		client_sk->sk->sk_rcvtimeo = KSMBD_TCP_RECV_TIMEOUT;
 		client_sk->sk->sk_sndtimeo = KSMBD_TCP_SEND_TIMEOUT;
@@ -306,16 +319,18 @@ static int ksmbd_tcp_run_kthread(struct interface *iface)
 
 /**
  * ksmbd_tcp_readv() - read data from socket in given iovec
- * @t:		TCP transport instance
- * @iov_orig:	base IO vector
- * @nr_segs:	number of segments in base iov
- * @to_read:	number of bytes to read from socket
+ * @t:			TCP transport instance
+ * @iov_orig:		base IO vector
+ * @nr_segs:		number of segments in base iov
+ * @to_read:		number of bytes to read from socket
+ * @max_retries:	maximum retry count
  *
  * Return:	on success return number of bytes read from socket,
  *		otherwise return error number
  */
 static int ksmbd_tcp_readv(struct tcp_transport *t, struct kvec *iov_orig,
-			   unsigned int nr_segs, unsigned int to_read)
+			   unsigned int nr_segs, unsigned int to_read,
+			   int max_retries)
 {
 	int length = 0;
 	int total_read;
@@ -346,15 +361,26 @@ static int ksmbd_tcp_readv(struct tcp_transport *t, struct kvec *iov_orig,
 		if (length == -EINTR) {
 			total_read = -ESHUTDOWN;
 			break;
-		} else if (conn->status == KSMBD_SESS_NEED_RECONNECT) {
+		} else if (ksmbd_conn_need_reconnect(conn)) {
 			total_read = -EAGAIN;
 			break;
 		} else if (length == -ERESTARTSYS || length == -EAGAIN) {
+			/*
+			 * If max_retries is negative, Allow unlimited
+			 * retries to keep connection with inactive sessions.
+			 */
+			if (max_retries == 0) {
+				total_read = length;
+				break;
+			} else if (max_retries > 0) {
+				max_retries--;
+			}
+
 			usleep_range(1000, 2000);
 			length = 0;
 			continue;
 		} else if (length <= 0) {
-			total_read = -EAGAIN;
+			total_read = length;
 			break;
 		}
 	}
@@ -370,14 +396,15 @@ static int ksmbd_tcp_readv(struct tcp_transport *t, struct kvec *iov_orig,
  * Return:	on success return number of bytes read from socket,
  *		otherwise return error number
  */
-static int ksmbd_tcp_read(struct ksmbd_transport *t, char *buf, unsigned int to_read)
+static int ksmbd_tcp_read(struct ksmbd_transport *t, char *buf,
+			  unsigned int to_read, int max_retries)
 {
 	struct kvec iov;
 
 	iov.iov_base = buf;
 	iov.iov_len = to_read;
 
-	return ksmbd_tcp_readv(TCP_TRANS(t), &iov, 1, to_read);
+	return ksmbd_tcp_readv(TCP_TRANS(t), &iov, 1, to_read, max_retries);
 }
 
 static int ksmbd_tcp_writev(struct ksmbd_transport *t, struct kvec *iov,
@@ -393,6 +420,8 @@ static int ksmbd_tcp_writev(struct ksmbd_transport *t, struct kvec *iov,
 static void ksmbd_tcp_disconnect(struct ksmbd_transport *t)
 {
 	free_transport(TCP_TRANS(t));
+	if (server_conf.max_connections)
+		atomic_dec(&active_num_conn);
 }
 
 static void tcp_destroy_socket(struct socket *ksmbd_socket)
diff --git a/vfs.c b/vfs.c
index 3c0e605..04f4bb9 100644
--- a/vfs.c
+++ b/vfs.c
@@ -6,10 +6,13 @@
 
 #include <linux/kernel.h>
 #include <linux/fs.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#include <linux/filelock.h>
+#endif
 #include <linux/uaccess.h>
 #include <linux/backing-dev.h>
 #include <linux/writeback.h>
-#include <linux/version.h>
 #include <linux/xattr.h>
 #include <linux/falloc.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0)
@@ -76,7 +79,11 @@ static void ksmbd_vfs_inherit_owner(struct ksmbd_work *work,
  *
  * the reference count of @parent isn't incremented.
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_lock_parent(struct mnt_idmap *idmap, struct dentry *parent,
+#else
 int ksmbd_vfs_lock_parent(struct user_namespace *user_ns, struct dentry *parent,
+#endif
 			  struct dentry *child)
 {
 	struct dentry *dentry;
@@ -84,7 +91,11 @@ int ksmbd_vfs_lock_parent(struct user_namespace *user_ns, struct dentry *parent,
 
 	inode_lock_nested(d_inode(parent), I_MUTEX_PARENT);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	dentry = lookup_one(idmap, child->d_name.name, parent,
+#else
 	dentry = lookup_one(user_ns, child->d_name.name, parent,
+#endif
 			    child->d_name.len);
 #else
 	dentry = lookup_one_len(child->d_name.name, parent,
@@ -108,21 +119,33 @@ out_err:
 	return ret;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_may_delete(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_may_delete(struct user_namespace *user_ns,
+#endif
 			 struct dentry *dentry)
 {
 	struct dentry *parent;
 	int ret;
 
 	parent = dget_parent(dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ret = ksmbd_vfs_lock_parent(idmap, parent, dentry);
+#else
 	ret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);
+#endif
 	if (ret) {
 		dput(parent);
 		return ret;
 	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ret = inode_permission(idmap, d_inode(parent),
+#else
 	ret = inode_permission(user_ns, d_inode(parent),
+#endif
 			       MAY_EXEC | MAY_WRITE);
 #else
 	ret = inode_permission(d_inode(parent), MAY_EXEC | MAY_WRITE);
@@ -133,7 +156,11 @@ int ksmbd_vfs_may_delete(struct user_namespace *user_ns,
 	return ret;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_query_maximal_access(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_query_maximal_access(struct user_namespace *user_ns,
+#endif
 				   struct dentry *dentry, __le32 *daccess)
 {
 	struct dentry *parent;
@@ -142,7 +169,11 @@ int ksmbd_vfs_query_maximal_access(struct user_namespace *user_ns,
 	*daccess = cpu_to_le32(FILE_READ_ATTRIBUTES | READ_CONTROL);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	if (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_WRITE))
+#else
 	if (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_WRITE))
+#endif
 #else
 	if (!inode_permission(d_inode(dentry), MAY_OPEN | MAY_WRITE))
 #endif
@@ -152,28 +183,44 @@ int ksmbd_vfs_query_maximal_access(struct user_namespace *user_ns,
 				FILE_DELETE_CHILD);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	if (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_READ))
+#else
 	if (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_READ))
+#endif
 #else
 	if (!inode_permission(d_inode(dentry), MAY_OPEN | MAY_READ))
 #endif
 		*daccess |= FILE_READ_DATA_LE | FILE_READ_EA_LE;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	if (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_EXEC))
+#else
 	if (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_EXEC))
+#endif
 #else
 	if (!inode_permission(d_inode(dentry), MAY_OPEN | MAY_EXEC))
 #endif
 		*daccess |= FILE_EXECUTE_LE;
 
 	parent = dget_parent(dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ret = ksmbd_vfs_lock_parent(idmap, parent, dentry);
+#else
 	ret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);
+#endif
 	if (ret) {
 		dput(parent);
 		return ret;
 	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	if (!inode_permission(idmap, d_inode(parent), MAY_EXEC | MAY_WRITE))
+#else
 	if (!inode_permission(user_ns, d_inode(parent), MAY_EXEC | MAY_WRITE))
+#endif
 #else
 	if (!inode_permission(d_inode(parent), MAY_EXEC | MAY_WRITE))
 #endif
@@ -210,7 +257,13 @@ int ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode)
 
 	mode |= S_IFREG;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	err = vfs_create(mnt_user_ns(path.mnt), d_inode(path.dentry), dentry, mode, true);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_create(mnt_idmap(path.mnt), d_inode(path.dentry),
+			 dentry, mode, true);
+#else
+	err = vfs_create(mnt_user_ns(path.mnt), d_inode(path.dentry),
+			 dentry, mode, true);
+#endif
 #else
 	err = vfs_create(d_inode(path.dentry), dentry, mode, true);
 #endif
@@ -234,7 +287,11 @@ int ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode)
  */
 int ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct path path;
 	struct dentry *dentry;
 	int err;
@@ -250,10 +307,18 @@ int ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode)
 		return err;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = mnt_idmap(path.mnt);
+#else
 	user_ns = mnt_user_ns(path.mnt);
+#endif
 	mode |= S_IFDIR;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_mkdir(idmap, d_inode(path.dentry), dentry, mode);
+#else
 	err = vfs_mkdir(user_ns, d_inode(path.dentry), dentry, mode);
+#endif
 #else
 	err = vfs_mkdir(d_inode(path.dentry), dentry, mode);
 #endif
@@ -263,7 +328,11 @@ int ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode)
 		struct dentry *d;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		d = lookup_one(idmap, dentry->d_name.name, dentry->d_parent,
+#else
 		d = lookup_one(user_ns, dentry->d_name.name, dentry->d_parent,
+#endif
 			       dentry->d_name.len);
 #else
 		d = lookup_one_len(dentry->d_name.name, dentry->d_parent,
@@ -289,7 +358,11 @@ out:
 	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static ssize_t ksmbd_vfs_getcasexattr(struct mnt_idmap *idmap,
+#else
 static ssize_t ksmbd_vfs_getcasexattr(struct user_namespace *user_ns,
+#endif
 				      struct dentry *dentry, char *attr_name,
 				      int attr_name_len, char **attr_value)
 {
@@ -306,7 +379,11 @@ static ssize_t ksmbd_vfs_getcasexattr(struct user_namespace *user_ns,
 		if (strncasecmp(attr_name, name, attr_name_len))
 			continue;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		value_len = ksmbd_vfs_getxattr(idmap,
+#else
 		value_len = ksmbd_vfs_getxattr(user_ns,
+#endif
 					       dentry,
 					       name,
 					       attr_value);
@@ -329,7 +406,11 @@ static int ksmbd_vfs_stream_read(struct ksmbd_file *fp, char *buf, loff_t *pos,
 	ksmbd_debug(VFS, "read stream data pos : %llu, count : %zd\n",
 		    *pos, count);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	v_len = ksmbd_vfs_getcasexattr(file_mnt_idmap(fp->filp),
+#else
 	v_len = ksmbd_vfs_getcasexattr(file_mnt_user_ns(fp->filp),
+#endif
 				       fp->filp->f_path.dentry,
 				       fp->stream.name,
 				       fp->stream.size,
@@ -365,7 +446,11 @@ static int check_lock_range(struct file *filp, loff_t start, loff_t end,
 			    unsigned char type)
 {
 	struct file_lock *flock;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+	struct file_lock_context *ctx = locks_inode_context(file_inode(filp));
+#else
 	struct file_lock_context *ctx = file_inode(filp)->i_flctx;
+#endif
 	int error = 0;
 
 	if (!ctx || list_empty_careful(&ctx->flc_posix))
@@ -453,7 +538,11 @@ static int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,
 				  size_t count)
 {
 	char *stream_buf = NULL, *wbuf;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(fp->filp);
+#else
 	struct user_namespace *user_ns = file_mnt_user_ns(fp->filp);
+#endif
 	size_t size, v_len;
 	int err = 0;
 
@@ -466,7 +555,11 @@ static int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,
 		count = (*pos + count) - XATTR_SIZE_MAX;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	v_len = ksmbd_vfs_getcasexattr(idmap,
+#else
 	v_len = ksmbd_vfs_getcasexattr(user_ns,
+#endif
 				       fp->filp->f_path.dentry,
 				       fp->stream.name,
 				       fp->stream.size,
@@ -492,7 +585,11 @@ static int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,
 
 	memcpy(&stream_buf[*pos], buf, count);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_setxattr(idmap,
+#else
 	err = ksmbd_vfs_setxattr(user_ns,
+#endif
 				 fp->filp->f_path.dentry,
 				 fp->stream.name,
 				 (void *)stream_buf,
@@ -890,7 +987,11 @@ int ksmbd_vfs_fsync(struct ksmbd_work *work, u64 fid, u64 p_id)
  */
 int ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct path path;
 	struct dentry *parent;
 	int err;
@@ -905,9 +1006,17 @@ int ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)
 		return err;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = mnt_idmap(path.mnt);
+#else
 	user_ns = mnt_user_ns(path.mnt);
+#endif
 	parent = dget_parent(path.dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_lock_parent(idmap, parent, path.dentry);
+#else
 	err = ksmbd_vfs_lock_parent(user_ns, parent, path.dentry);
+#endif
 	if (err) {
 		dput(parent);
 		path_put(&path);
@@ -922,7 +1031,11 @@ int ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)
 
 	if (S_ISDIR(d_inode(path.dentry)->i_mode)) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		err = vfs_rmdir(idmap, d_inode(parent), path.dentry);
+#else
 		err = vfs_rmdir(user_ns, d_inode(parent), path.dentry);
+#endif
 #else
 		err = vfs_rmdir(d_inode(parent), path.dentry);
 #endif
@@ -931,7 +1044,11 @@ int ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)
 				    err);
 	} else {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		err = vfs_unlink(idmap, d_inode(parent), path.dentry, NULL);
+#else
 		err = vfs_unlink(user_ns, d_inode(parent), path.dentry, NULL);
+#endif
 #else
 		err = vfs_unlink(d_inode(parent), path.dentry, NULL);
 #endif
@@ -988,9 +1105,15 @@ int ksmbd_vfs_link(struct ksmbd_work *work, const char *oldname,
 	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_link(oldpath.dentry, mnt_idmap(newpath.mnt),
+		       d_inode(newpath.dentry),
+		       dentry, NULL);
+#else
 	err = vfs_link(oldpath.dentry, mnt_user_ns(newpath.mnt),
 		       d_inode(newpath.dentry),
 		       dentry, NULL);
+#endif
 #else
 	err = vfs_link(oldpath.dentry, d_inode(newpath.dentry), dentry, NULL);
 #endif
@@ -1029,6 +1152,16 @@ static int ksmbd_validate_entry_in_use(struct dentry *src_dent)
 	return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static int __ksmbd_vfs_rename(struct ksmbd_work *work,
+			      struct mnt_idmap *src_idmap,
+			      struct dentry *src_dent_parent,
+			      struct dentry *src_dent,
+			      struct mnt_idmap *dst_idmap,
+			      struct dentry *dst_dent_parent,
+			      struct dentry *trap_dent,
+			      char *dst_name)
+#else
 static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 			      struct user_namespace *src_user_ns,
 			      struct dentry *src_dent_parent,
@@ -1037,6 +1170,7 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 			      struct dentry *dst_dent_parent,
 			      struct dentry *trap_dent,
 			      char *dst_name)
+#endif
 {
 	struct dentry *dst_dent;
 	int err;
@@ -1060,8 +1194,13 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 		return -ENOMEM;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	dst_dent = lookup_one(dst_idmap, dst_name,
+			      dst_dent_parent, strlen(dst_name));
+#else
 	dst_dent = lookup_one(dst_user_ns, dst_name, dst_dent_parent,
 			      strlen(dst_name));
+#endif
 #else
 	dst_dent = lookup_one_len(dst_name, dst_dent_parent,
 				  strlen(dst_name));
@@ -1075,6 +1214,16 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 	err = -ENOTEMPTY;
 	if (dst_dent != trap_dent && !d_really_is_positive(dst_dent)) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		struct renamedata rd = {
+			.old_mnt_idmap	= src_idmap,
+			.old_dir	= d_inode(src_dent_parent),
+			.old_dentry	= src_dent,
+			.new_mnt_idmap	= dst_idmap,
+			.new_dir	= d_inode(dst_dent_parent),
+			.new_dentry	= dst_dent,
+		};
+#else
 		struct renamedata rd = {
 			.old_mnt_userns	= src_user_ns,
 			.old_dir	= d_inode(src_dent_parent),
@@ -1083,6 +1232,7 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 			.new_dir	= d_inode(dst_dent_parent),
 			.new_dentry	= dst_dent,
 		};
+#endif
 		err = vfs_rename(&rd);
 #else
 		err = vfs_rename(d_inode(src_dent_parent),
@@ -1105,7 +1255,11 @@ out:
 int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 			char *newname)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct path dst_path;
 	struct dentry *src_dent_parent, *dst_dent_parent;
 	struct dentry *src_dent, *trap_dent, *src_child;
@@ -1133,9 +1287,17 @@ int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 	trap_dent = lock_rename(src_dent_parent, dst_dent_parent);
 	dget(src_dent);
 	dget(dst_dent_parent);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = file_mnt_idmap(fp->filp);
+#else
 	user_ns = file_mnt_user_ns(fp->filp);
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	src_child = lookup_one(idmap, src_dent->d_name.name, src_dent_parent,
+#else
 	src_child = lookup_one(user_ns, src_dent->d_name.name, src_dent_parent,
+#endif
 			       src_dent->d_name.len);
 #else
 	src_child = lookup_one_len(src_dent->d_name.name, src_dent_parent,
@@ -1153,6 +1315,16 @@ int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 	}
 	dput(src_child);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = __ksmbd_vfs_rename(work,
+				 idmap,
+				 src_dent_parent,
+				 src_dent,
+				 mnt_idmap(dst_path.mnt),
+				 dst_dent_parent,
+				 trap_dent,
+				 dst_name);
+#else
 	err = __ksmbd_vfs_rename(work,
 				 user_ns,
 				 src_dent_parent,
@@ -1161,6 +1333,7 @@ int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 				 dst_dent_parent,
 				 trap_dent,
 				 dst_name);
+#endif
 out_lock:
 	dput(src_dent);
 	dput(dst_dent_parent);
@@ -1249,11 +1422,19 @@ ssize_t ksmbd_vfs_listxattr(struct dentry *dentry, char **list)
 	return size;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static ssize_t ksmbd_vfs_xattr_len(struct mnt_idmap *idmap,
+#else
 static ssize_t ksmbd_vfs_xattr_len(struct user_namespace *user_ns,
+#endif
 				   struct dentry *dentry, char *xattr_name)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	return vfs_getxattr(idmap, dentry, xattr_name, NULL, 0);
+#else
 	return vfs_getxattr(user_ns, dentry, xattr_name, NULL, 0);
+#endif
 #else
 	return vfs_getxattr(dentry, xattr_name, NULL, 0);
 #endif
@@ -1261,14 +1442,22 @@ static ssize_t ksmbd_vfs_xattr_len(struct user_namespace *user_ns,
 
 /**
  * ksmbd_vfs_getxattr() - vfs helper for smb get extended attributes value
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
++  @idmap:	idmap
+#else
 +  @user_ns:	user namespace
+#endif
  * @dentry:	dentry of file for getting xattrs
  * @xattr_name:	name of xattr name to query
  * @xattr_buf:	destination buffer xattr value
  *
  * Return:	read xattr value length on success, otherwise error
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ssize_t ksmbd_vfs_getxattr(struct mnt_idmap *idmap,
+#else
 ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry,
 			   char *xattr_name, char **xattr_buf)
 {
@@ -1276,7 +1465,11 @@ ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
 	char *buf;
 
 	*xattr_buf = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	xattr_len = ksmbd_vfs_xattr_len(idmap, dentry, xattr_name);
+#else
 	xattr_len = ksmbd_vfs_xattr_len(user_ns, dentry, xattr_name);
+#endif
 	if (xattr_len < 0)
 		return xattr_len;
 
@@ -1285,7 +1478,11 @@ ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
 		return -ENOMEM;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	xattr_len = vfs_getxattr(idmap, dentry, xattr_name,
+#else
 	xattr_len = vfs_getxattr(user_ns, dentry, xattr_name,
+#endif
 				 (void *)buf, xattr_len);
 #else
 	xattr_len = vfs_getxattr(dentry, xattr_name, (void *)buf, xattr_len);
@@ -1299,7 +1496,11 @@ ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
 
 /**
  * ksmbd_vfs_setxattr() - vfs helper for smb set extended attributes value
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ * @idmap:	idmap of the relevant mount
+#else
  * @user_ns:	user namespace
+#endif
  * @dentry:	dentry to set XATTR at
  * @name:	xattr name for setxattr
  * @value:	xattr value to set
@@ -1308,7 +1509,11 @@ ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
  *
  * Return:	0 on success, otherwise error
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_setxattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_setxattr(struct user_namespace *user_ns,
+#endif
 		       struct dentry *dentry, const char *attr_name,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 		       void *attr_value, size_t attr_size, int flags)
@@ -1319,7 +1524,11 @@ int ksmbd_vfs_setxattr(struct user_namespace *user_ns,
 	int err;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_setxattr(idmap,
+#else
 	err = vfs_setxattr(user_ns,
+#endif
 			   dentry,
 #else
 	err = vfs_setxattr(dentry,
@@ -1386,8 +1595,13 @@ struct dentry *ksmbd_vfs_kern_path_create(struct ksmbd_work *work,
 	return dent;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_acl_xattrs(struct mnt_idmap *idmap,
+				struct dentry *dentry)
+#else
 int ksmbd_vfs_remove_acl_xattrs(struct user_namespace *user_ns,
 				struct dentry *dentry)
+#endif
 {
 	char *name, *xattr_list = NULL;
 	ssize_t xattr_list_len;
@@ -1409,7 +1623,15 @@ int ksmbd_vfs_remove_acl_xattrs(struct user_namespace *user_ns,
 			     sizeof(XATTR_NAME_POSIX_ACL_ACCESS) - 1) ||
 		    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT,
 			     sizeof(XATTR_NAME_POSIX_ACL_DEFAULT) - 1)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			err = vfs_remove_acl(idmap, dentry, name);
+#else
+			err = vfs_remove_acl(user_ns, dentry, name);
+#endif
+#else
 			err = ksmbd_vfs_remove_xattr(user_ns, dentry, name);
+#endif
 			if (err)
 				ksmbd_debug(SMB,
 					    "remove acl xattr failed : %s\n", name);
@@ -1420,7 +1642,11 @@ out:
 	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_sd_xattrs(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_remove_sd_xattrs(struct user_namespace *user_ns,
+#endif
 			       struct dentry *dentry)
 {
 	char *name, *xattr_list = NULL;
@@ -1440,7 +1666,11 @@ int ksmbd_vfs_remove_sd_xattrs(struct user_namespace *user_ns,
 		ksmbd_debug(SMB, "%s, len %zd\n", name, strlen(name));
 
 		if (!strncmp(name, XATTR_NAME_SD, XATTR_NAME_SD_LEN)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			err = ksmbd_vfs_remove_xattr(idmap, dentry, name);
+#else
 			err = ksmbd_vfs_remove_xattr(user_ns, dentry, name);
+#endif
 			if (err)
 				ksmbd_debug(SMB, "remove xattr failed : %s\n", name);
 		}
@@ -1450,7 +1680,11 @@ out:
 	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct mnt_idmap *idmap,
+#else
 static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct user_namespace *user_ns,
+#endif
 							    struct inode *inode,
 							    int acl_type)
 {
@@ -1463,7 +1697,11 @@ static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct user_namespac
 	if (!IS_ENABLED(CONFIG_FS_POSIX_ACL))
 		return NULL;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+	posix_acls = get_inode_acl(inode, acl_type);
+#else
 	posix_acls = get_acl(inode, acl_type);
+#endif
 	if (!posix_acls)
 		return NULL;
 
@@ -1480,14 +1718,22 @@ static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct user_namespac
 		switch (pa_entry->e_tag) {
 		case ACL_USER:
 			xa_entry->type = SMB_ACL_USER;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			xa_entry->uid = posix_acl_uid_translate(idmap, pa_entry);
+#else
 			xa_entry->uid = posix_acl_uid_translate(user_ns, pa_entry);
+#endif
 			break;
 		case ACL_USER_OBJ:
 			xa_entry->type = SMB_ACL_USER_OBJ;
 			break;
 		case ACL_GROUP:
 			xa_entry->type = SMB_ACL_GROUP;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			xa_entry->gid = posix_acl_gid_translate(idmap, pa_entry);
+#else
 			xa_entry->gid = posix_acl_gid_translate(user_ns, pa_entry);
+#endif
 			break;
 		case ACL_GROUP_OBJ:
 			xa_entry->type = SMB_ACL_GROUP_OBJ;
@@ -1516,7 +1762,11 @@ out:
 }
 
 int ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			   struct mnt_idmap *idmap,
+#else
 			   struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry,
 			   struct smb_ntsd *pntsd, int len)
 {
@@ -1549,13 +1799,25 @@ int ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,
 		return rc;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,
+#else
 	smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
+#endif
 						 ACL_TYPE_ACCESS);
 	if (S_ISDIR(inode->i_mode))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,
+#else
 		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
+#endif
 							     ACL_TYPE_DEFAULT);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ndr_encode_posix_acl(&acl_ndr, idmap, inode,
+#else
 	rc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode,
+#endif
 				  smb_acl, def_smb_acl);
 	if (rc) {
 		pr_err("failed to encode ndr to posix acl\n");
@@ -1575,7 +1837,11 @@ int ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,
 		goto out;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_setxattr(idmap, dentry,
+#else
 	rc = ksmbd_vfs_setxattr(user_ns, dentry,
+#endif
 				XATTR_NAME_SD, sd_ndr.data,
 				sd_ndr.offset, 0);
 	if (rc < 0)
@@ -1590,7 +1856,11 @@ out:
 }
 
 int ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			   struct mnt_idmap *idmap,
+#else
 			   struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry,
 			   struct smb_ntsd **pntsd)
 {
@@ -1602,7 +1872,11 @@ int ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,
 	struct xattr_smb_acl *smb_acl = NULL, *def_smb_acl = NULL;
 	__u8 cmp_hash[XATTR_SD_HASH_SIZE] = {0};
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_getxattr(idmap, dentry, XATTR_NAME_SD, &n.data);
+#else
 	rc = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_SD, &n.data);
+#endif
 	if (rc <= 0)
 		return rc;
 
@@ -1611,13 +1885,25 @@ int ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,
 	if (rc)
 		goto free_n_data;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,
+#else
 	smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
+#endif
 						 ACL_TYPE_ACCESS);
 	if (S_ISDIR(inode->i_mode))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,
+#else
 		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
+#endif
 							     ACL_TYPE_DEFAULT);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ndr_encode_posix_acl(&acl_ndr, idmap, inode, smb_acl,
+#else
 	rc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode, smb_acl,
+#endif
 				  def_smb_acl);
 	if (rc) {
 		pr_err("failed to encode ndr to posix acl\n");
@@ -1664,7 +1950,11 @@ free_n_data:
 	return rc;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_set_dos_attrib_xattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,
+#endif
 				   struct dentry *dentry,
 				   struct xattr_dos_attrib *da)
 {
@@ -1675,7 +1965,11 @@ int ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,
 	if (err)
 		return err;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_setxattr(idmap, dentry, XATTR_NAME_DOS_ATTRIBUTE,
+#else
 	err = ksmbd_vfs_setxattr(user_ns, dentry, XATTR_NAME_DOS_ATTRIBUTE,
+#endif
 				 (void *)n.data, n.offset, 0);
 	if (err)
 		ksmbd_debug(SMB, "failed to store dos attribute in xattr\n");
@@ -1684,14 +1978,22 @@ int ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,
 	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_get_dos_attrib_xattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_get_dos_attrib_xattr(struct user_namespace *user_ns,
+#endif
 				   struct dentry *dentry,
 				   struct xattr_dos_attrib *da)
 {
 	struct ndr n;
 	int err;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_getxattr(idmap, dentry, XATTR_NAME_DOS_ATTRIBUTE,
+#else
 	err = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_DOS_ATTRIBUTE,
+#endif
 				 (char **)&n.data);
 	if (err > 0) {
 		n.length = err;
@@ -1804,31 +2106,53 @@ int ksmbd_vfs_fqar_lseek(struct ksmbd_file *fp, loff_t start, loff_t length,
 	return ret;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_xattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_remove_xattr(struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry, char *attr_name)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	return vfs_removexattr(idmap, dentry, attr_name);
+#else
 	return vfs_removexattr(user_ns, dentry, attr_name);
+#endif
 #else
 	return vfs_removexattr(dentry, attr_name);
 #endif
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_unlink(struct mnt_idmap *idmap,
+		     struct dentry *dir, struct dentry *dentry)
+#else
 int ksmbd_vfs_unlink(struct user_namespace *user_ns,
 		     struct dentry *dir, struct dentry *dentry)
+#endif
 {
 	int err = 0;
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_lock_parent(idmap, dir, dentry);
+#else
 	err = ksmbd_vfs_lock_parent(user_ns, dir, dentry);
+#endif
 	if (err)
 		return err;
 
 	dget(dentry);
 	if (S_ISDIR(d_inode(dentry)->i_mode))
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		err = vfs_rmdir(idmap, d_inode(dir), dentry);
+	else
+		err = vfs_unlink(idmap, d_inode(dir), dentry, NULL);
+#else
 		err = vfs_rmdir(user_ns, d_inode(dir), dentry);
 	else
 		err = vfs_unlink(user_ns, d_inode(dir), dentry, NULL);
+#endif
 #else
 		err = vfs_rmdir(d_inode(dir), dentry);
 	else
@@ -1912,7 +2236,13 @@ static int __dir_empty(struct dir_context *ctx, const char *name, int namlen,
 	buf = container_of(ctx, struct ksmbd_readdir_data, ctx);
 	buf->dirent_count++;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 	return buf->dirent_count <= 2;
+#else
+	if (buf->dirent_count > 2)
+		return -ENOTEMPTY;
+	return 0;
+#endif
 }
 
 /**
@@ -2211,16 +2541,27 @@ void *ksmbd_vfs_init_kstat(char **p, struct ksmbd_kstat *ksmbd_kstat)
 	return info;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
+				struct mnt_idmap *idmap,
+				struct dentry *dentry,
+				struct ksmbd_kstat *ksmbd_kstat)
+#else
 int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
 				struct user_namespace *user_ns,
 				struct dentry *dentry,
 				struct ksmbd_kstat *ksmbd_kstat)
+#endif
 {
 	u64 time;
 	int rc;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	generic_fillattr(idmap, d_inode(dentry), ksmbd_kstat->kstat);
+#else
 	generic_fillattr(user_ns, d_inode(dentry), ksmbd_kstat->kstat);
+#endif
 #else
 	generic_fillattr(d_inode(dentry), ksmbd_kstat->kstat);
 #endif
@@ -2241,7 +2582,11 @@ int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
 				   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
 		struct xattr_dos_attrib da;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = ksmbd_vfs_get_dos_attrib_xattr(idmap, dentry, &da);
+#else
 		rc = ksmbd_vfs_get_dos_attrib_xattr(user_ns, dentry, &da);
+#endif
 		if (rc > 0) {
 			ksmbd_kstat->file_attributes = cpu_to_le32(da.attr);
 			ksmbd_kstat->create_time = da.create_time;
@@ -2253,7 +2598,11 @@ int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
 	return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ssize_t ksmbd_vfs_casexattr_len(struct mnt_idmap *idmap,
+#else
 ssize_t ksmbd_vfs_casexattr_len(struct user_namespace *user_ns,
+#endif
 				struct dentry *dentry, char *attr_name,
 				int attr_name_len)
 {
@@ -2270,7 +2619,11 @@ ssize_t ksmbd_vfs_casexattr_len(struct user_namespace *user_ns,
 		if (strncasecmp(attr_name, name, attr_name_len))
 			continue;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		value_len = ksmbd_vfs_xattr_len(idmap, dentry, name);
+#else
 		value_len = ksmbd_vfs_xattr_len(user_ns, dentry, name);
+#endif
 		break;
 	}
 
@@ -2397,11 +2750,17 @@ void ksmbd_vfs_posix_lock_unblock(struct file_lock *flock)
 	locks_delete_block(flock);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_set_init_posix_acl(struct mnt_idmap *idmap,
+				 struct dentry *dentry)
+#else
 int ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,
-				 struct inode *inode)
+				 struct dentry *dentry)
+#endif
 {
 	struct posix_acl_state acl_state;
 	struct posix_acl *acls;
+	struct inode *inode = d_inode(dentry);
 	int rc;
 
 	if (!IS_ENABLED(CONFIG_FS_POSIX_ACL))
@@ -2431,7 +2790,15 @@ int ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,
 	}
 	posix_state_to_acl(&acl_state, acls->a_entries);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = set_posix_acl(idmap, dentry, ACL_TYPE_ACCESS, acls);
+#else
+	rc = set_posix_acl(user_ns, dentry, ACL_TYPE_ACCESS, acls);
+#endif
+#else
 	rc = set_posix_acl(user_ns, inode, ACL_TYPE_ACCESS, acls);
+#endif
 #else
 	rc = set_posix_acl(inode, ACL_TYPE_ACCESS, acls);
 #endif
@@ -2441,8 +2808,15 @@ int ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,
 	else if (S_ISDIR(inode->i_mode)) {
 		posix_state_to_acl(&acl_state, acls->a_entries);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-		rc = set_posix_acl(user_ns, inode, ACL_TYPE_DEFAULT,
-				   acls);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = set_posix_acl(idmap, dentry, ACL_TYPE_DEFAULT, acls);
+#else
+		rc = set_posix_acl(user_ns, dentry, ACL_TYPE_DEFAULT, acls);
+#endif
+#else
+		rc = set_posix_acl(user_ns, inode, ACL_TYPE_DEFAULT, acls);
+#endif
 #else
 		rc = set_posix_acl(inode, ACL_TYPE_DEFAULT, acls);
 #endif
@@ -2455,17 +2829,27 @@ int ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,
 	return rc;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_inherit_posix_acl(struct mnt_idmap *idmap,
+				struct dentry *dentry, struct inode *parent_inode)
+#else
 int ksmbd_vfs_inherit_posix_acl(struct user_namespace *user_ns,
-				struct inode *inode, struct inode *parent_inode)
+				struct dentry *dentry, struct inode *parent_inode)
+#endif
 {
 	struct posix_acl *acls;
 	struct posix_acl_entry *pace;
+	struct inode *inode = d_inode(dentry);
 	int rc, i;
 
 	if (!IS_ENABLED(CONFIG_FS_POSIX_ACL))
 		return -EOPNOTSUPP;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+	acls = get_inode_acl(parent_inode, ACL_TYPE_DEFAULT);
+#else
 	acls = get_acl(parent_inode, ACL_TYPE_DEFAULT);
+#endif
 	if (!acls)
 		return -ENOENT;
 	pace = acls->a_entries;
@@ -2478,7 +2862,15 @@ int ksmbd_vfs_inherit_posix_acl(struct user_namespace *user_ns,
 	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = set_posix_acl(idmap, dentry, ACL_TYPE_ACCESS, acls);
+#else
+	rc = set_posix_acl(user_ns, dentry, ACL_TYPE_ACCESS, acls);
+#endif
+#else
 	rc = set_posix_acl(user_ns, inode, ACL_TYPE_ACCESS, acls);
+#endif
 #else
 	rc = set_posix_acl(inode, ACL_TYPE_ACCESS, acls);
 #endif
@@ -2487,8 +2879,18 @@ int ksmbd_vfs_inherit_posix_acl(struct user_namespace *user_ns,
 			    rc);
 	if (S_ISDIR(inode->i_mode)) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = set_posix_acl(idmap, dentry, ACL_TYPE_DEFAULT,
+				   acls);
+#else
+		rc = set_posix_acl(user_ns, dentry, ACL_TYPE_DEFAULT,
+				   acls);
+#endif
+#else
 		rc = set_posix_acl(user_ns, inode, ACL_TYPE_DEFAULT,
 				   acls);
+#endif
 #else
 		rc = set_posix_acl(inode, ACL_TYPE_DEFAULT, acls);
 #endif
diff --git a/vfs.h b/vfs.h
index b6e3682..d5fefbc 100644
--- a/vfs.h
+++ b/vfs.h
@@ -125,11 +125,19 @@ static inline struct user_namespace *file_mnt_user_ns(struct file *file)
 }
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_lock_parent(struct mnt_idmap *idmap, struct dentry *parent,
+			  struct dentry *child);
+int ksmbd_vfs_may_delete(struct mnt_idmap *idmap, struct dentry *dentry);
+int ksmbd_vfs_query_maximal_access(struct mnt_idmap *idmap,
+				   struct dentry *dentry, __le32 *daccess);
+#else
 int ksmbd_vfs_lock_parent(struct user_namespace *user_ns, struct dentry *parent,
 			  struct dentry *child);
 int ksmbd_vfs_may_delete(struct user_namespace *user_ns, struct dentry *dentry);
 int ksmbd_vfs_query_maximal_access(struct user_namespace *user_ns,
 				   struct dentry *dentry, __le32 *daccess);
+#endif
 int ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode);
 int ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode);
 int ksmbd_vfs_read(struct ksmbd_work *work, struct ksmbd_file *fp,
@@ -171,14 +179,26 @@ struct ksmbd_file *ksmbd_vfs_dentry_open(struct ksmbd_work *work,
 					 const struct path *path, int flags,
 					 __le32 option, int fexist);
 ssize_t ksmbd_vfs_listxattr(struct dentry *dentry, char **list);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ssize_t ksmbd_vfs_getxattr(struct mnt_idmap *idmap,
+#else
 ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry,
 			   char *xattr_name,
 			   char **xattr_buf);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ssize_t ksmbd_vfs_casexattr_len(struct mnt_idmap *idmap,
+#else
 ssize_t ksmbd_vfs_casexattr_len(struct user_namespace *user_ns,
+#endif
 				struct dentry *dentry, char *attr_name,
 				int attr_name_len);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_setxattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_setxattr(struct user_namespace *user_ns,
+#endif
 		       struct dentry *dentry, const char *attr_name,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 		       void *attr_value, size_t attr_size, int flags);
@@ -190,7 +210,11 @@ int ksmbd_vfs_fsetxattr(struct ksmbd_work *work, const char *filename,
 			size_t attr_size, int flags);
 int ksmbd_vfs_xattr_stream_name(char *stream_name, char **xattr_stream_name,
 				size_t *xattr_stream_name_size, int s_type);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_xattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_remove_xattr(struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry, char *attr_name);
 int ksmbd_vfs_kern_path(struct ksmbd_work *work,
 			char *name, unsigned int flags, struct path *path,
@@ -207,37 +231,83 @@ struct file_allocated_range_buffer;
 int ksmbd_vfs_fqar_lseek(struct ksmbd_file *fp, loff_t start, loff_t length,
 			 struct file_allocated_range_buffer *ranges,
 			 unsigned int in_count, unsigned int *out_count);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_unlink(struct mnt_idmap *idmap, struct dentry *dir,
+		     struct dentry *dentry);
+#else
 int ksmbd_vfs_unlink(struct user_namespace *user_ns,
 		     struct dentry *dir, struct dentry *dentry);
+#endif
 void *ksmbd_vfs_init_kstat(char **p, struct ksmbd_kstat *ksmbd_kstat);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
+				struct mnt_idmap *idmap,
+				struct dentry *dentry,
+				struct ksmbd_kstat *ksmbd_kstat);
+#else
 int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
 				struct user_namespace *user_ns,
 				struct dentry *dentry,
 				struct ksmbd_kstat *ksmbd_kstat);
+#endif
 void ksmbd_vfs_posix_lock_wait(struct file_lock *flock);
 int ksmbd_vfs_posix_lock_wait_timeout(struct file_lock *flock, long timeout);
 void ksmbd_vfs_posix_lock_unblock(struct file_lock *flock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_acl_xattrs(struct mnt_idmap *idmap,
+				struct dentry *dentry);
+#else
 int ksmbd_vfs_remove_acl_xattrs(struct user_namespace *user_ns,
 				struct dentry *dentry);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_sd_xattrs(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_remove_sd_xattrs(struct user_namespace *user_ns,
+#endif
 			       struct dentry *dentry);
 int ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			   struct mnt_idmap *idmap,
+#else
 			   struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry,
 			   struct smb_ntsd *pntsd, int len);
 int ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			   struct mnt_idmap *idmap,
+#else
 			   struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry,
 			   struct smb_ntsd **pntsd);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_set_dos_attrib_xattr(struct mnt_idmap *idmap,
+				   struct dentry *dentry,
+				   struct xattr_dos_attrib *da);
+int ksmbd_vfs_get_dos_attrib_xattr(struct mnt_idmap *idmap,
+				   struct dentry *dentry,
+				   struct xattr_dos_attrib *da);
+#else
 int ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,
 				   struct dentry *dentry,
 				   struct xattr_dos_attrib *da);
 int ksmbd_vfs_get_dos_attrib_xattr(struct user_namespace *user_ns,
 				   struct dentry *dentry,
 				   struct xattr_dos_attrib *da);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_set_init_posix_acl(struct mnt_idmap *idmap,
+				 struct dentry *dentry);
+int ksmbd_vfs_inherit_posix_acl(struct mnt_idmap *idmap,
+				struct dentry *dentry,
+				struct inode *parent_inode);
+#else
 int ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,
-				 struct inode *inode);
+				 struct dentry *dentry);
 int ksmbd_vfs_inherit_posix_acl(struct user_namespace *user_ns,
-				struct inode *inode,
+				struct dentry *dentry,
 				struct inode *parent_inode);
+#endif
 #endif /* __KSMBD_VFS_H__ */
diff --git a/vfs_cache.c b/vfs_cache.c
index 74433e3..ce0f20b 100644
--- a/vfs_cache.c
+++ b/vfs_cache.c
@@ -5,6 +5,10 @@
  */
 
 #include <linux/fs.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#include <linux/filelock.h>
+#endif
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 
@@ -251,7 +255,11 @@ static void __ksmbd_inode_close(struct ksmbd_file *fp)
 	filp = fp->filp;
 	if (ksmbd_stream_fd(fp) && (ci->m_flags & S_DEL_ON_CLS_STREAM)) {
 		ci->m_flags &= ~S_DEL_ON_CLS_STREAM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		err = ksmbd_vfs_remove_xattr(file_mnt_idmap(filp),
+#else
 		err = ksmbd_vfs_remove_xattr(file_mnt_user_ns(filp),
+#endif
 					     filp->f_path.dentry,
 					     fp->stream.name);
 		if (err)
@@ -266,7 +274,11 @@ static void __ksmbd_inode_close(struct ksmbd_file *fp)
 			dir = dentry->d_parent;
 			ci->m_flags &= ~(S_DEL_ON_CLS | S_DEL_PENDING);
 			write_unlock(&ci->m_lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			ksmbd_vfs_unlink(file_mnt_idmap(filp), dir, dentry);
+#else
 			ksmbd_vfs_unlink(file_mnt_user_ns(filp), dir, dentry);
+#endif
 			write_lock(&ci->m_lock);
 		}
 		write_unlock(&ci->m_lock);
@@ -366,12 +378,11 @@ static void __put_fd_final(struct ksmbd_work *work, struct ksmbd_file *fp)
 
 static void set_close_state_blocked_works(struct ksmbd_file *fp)
 {
-	struct ksmbd_work *cancel_work, *ctmp;
+	struct ksmbd_work *cancel_work;
 
 	spin_lock(&fp->f_lock);
-	list_for_each_entry_safe(cancel_work, ctmp, &fp->blocked_works,
+	list_for_each_entry(cancel_work, &fp->blocked_works,
 				 fp_entry) {
-		list_del(&cancel_work->fp_entry);
 		cancel_work->state = KSMBD_WORK_CLOSED;
 		cancel_work->cancel_fn(cancel_work->cancel_argv);
 	}
